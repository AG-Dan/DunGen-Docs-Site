{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DunGen","text":"<p>DunGen is a Unity editor extension designed to make procedural dungeon generation quick and easy\u2014both in-editor and at runtime.</p> <p>It follows a room-based approach: you create prefab \"rooms\" (called <code>Tiles</code>), define doorway positions, and DunGen intelligently connects them to form complete dungeon layouts.</p> <p>Using an intuitive graph-based interface, you control the dungeon\u2019s structure\u2014defining the main path and optional branches, inserting special rooms like shops or boss arenas, and varying the visual style or theme throughout.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#2190-unreleased","title":"2.19.0 - [Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added a new culling camera component (DunGen &gt; Culling &gt; Culling Camera) to manage various types of culling<ul> <li>Culling can be per-camera or global (persisting the culling state regardless of camera for better performance)</li> <li>Available culling strategies:<ul> <li>Adjacency Culling: A replacement for the old BasicRoomCullingCamera and AdjacentRoomCulling components that have now been deprecated. Culls rooms based on adjacency to the room the player is currently in</li> <li>Portal Culling (New): Culls rooms based on visibility through doorways</li> <li>Frustum Culling (New): Culls all renderers in a room if the room bounds are outside the camera frustum. Can offer a small performance improvement over the built-in per-renderer frustum culling. Best used for top-down games where the player camera is outside the dungeon tiles, otherwise one of the other culling strategies is likely to be more effective</li> </ul> </li> </ul> </li> <li>Most DunGen components now have a Help URL. Clicking the help icon on the component header in the inspector will open the relevant documentation page in your web browser</li> <li>Added a tool for migrating DunGen data when upgrading to newer versions where the underlying data structures have changed<ul> <li>DunGen will prompt you to run the tool when upgrading to a new version, and can be run manually from the menu (<code>Window &gt; DunGen &gt; Run Project Migration</code>)</li> </ul> </li> <li>Added a new <code>OnDungeonGenerationComplete</code> event to the <code>DungeonGenerator</code> class that is fired when dungeon generation is complete and passes a reference to the generated <code>Dungeon</code> instance</li> <li>Connection rules in the <code>DungeonFlow</code> can now be applied using tags on the doorways, in addition to tags on the tiles</li> <li>Tile bounds calculation parameters (including layer mask and which types of components to consider) can now be customised<ul> <li>Globally in the DunGen project settings. Bounds calculations can also be overridden entirely by creating a custom type derived from <code>ITileBoundsCalculator</code> or <code>DefaultTileBoundsCalculator</code> and assigning it in the project settings</li> <li>Per-tile by adding a <code>TileBoundsOverride</code> component (or a custom component implementing <code>ITileBoundsCalculator</code>) to the tile prefab</li> </ul> </li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Generated dungeons are now nested inside their own container GameObject</li> <li>The <code>DungeonGenerator</code> class now has a <code>CompositeDungeon</code> property which stores dungeons that have been generated attached to one another. Generating a new non-attached dungeon will clear the previous composite dungeon</li> <li>In the collision settings, the old 'Avoid Collision with Other Dungeons' setting has been replaced with a new 'Multi-Dungeon Collision' drop-down with more options</li> <li>Individual debug drawing elements (collision visualization, path colouration) can now be toggled on and off independently in the dungeon generator settings</li> <li>Optimized doorway pair finding performance, especially on large dungeons with many doorways (~20% faster, ~80% reduction in GC allocations)</li> <li>Doorway prefabs (connectors and blockers) now use complex weights based on tile placement instead of a simple weight value<ul> <li>Includes: Main path weight, branch path weight, and a depth curve multiplier</li> </ul> </li> <li>Weighted entries (such as in a <code>TileSet</code> or <code>LocalPropSet</code>) now have a 'Depth Mode' option to control which depth value is used to modify the base weight:<ul> <li>None: No depth modification</li> <li>Auto: Uses main path depth for main path tiles, branch depth for branch tiles</li> <li>Main Path Depth: Uses main path depth, even for branch tiles</li> <li>Branch Depth: Uses branch depth, or 0 for main path tiles</li> </ul> </li> <li>The <code>Tile</code> component now supports multi-object editing</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Generating attached dungeons when using a custom Root GameObject should now work correctly</li> <li>Fixed an issue with tile collisions when using a Root GameObject that is not at the origin</li> <li>Fixed various transform issues where the dungeon would not correctly respect the position/rotation of its root or attachment point</li> <li>Attached dungeons will now automatically avoid collisions with the tile they are attached to</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Quadtree broad phase for collision detection has been removed. The quadtree implementation wasn't fully supported and the spatial hashing broad phase is more stable, simple, and performs better in almost all cases anyway</li> <li>Removed the version of the tile connection rule delegate that was deprecated in 2.16</li> </ul>"},{"location":"changelog/#21813-20251216","title":"2.18.13 - [2025/12/16]","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Updated <code>Tile</code> bounds transformation logic to more accurately handle rotation and scaling</li> <li>Fixed an issue sometimes preventing the automatic tile bounds calculation from running when saving a tile prefab</li> </ul>"},{"location":"changelog/#21812-20251210","title":"2.18.12 - [2025/12/10]","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed an issue causing tags to not be available on the <code>DoorwayProxy</code> objects</li> </ul>"},{"location":"changelog/#21811-20251125","title":"2.18.11 - [2025/11/25]","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Generating a dungeon in the scene view of the editor (using <code>Window &gt; DunGen &gt; Generate Dungeon</code>) will now spawn tiles as prefab instances, allowing for easier editing of generated dungeons</li> </ul>"},{"location":"changelog/#21810-20251005","title":"2.18.10 - [2025/10/05]","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>All samples now switch seamlessly between the old Input Manager and the new Input System package</li> </ul>"},{"location":"changelog/#2189-20250828","title":"2.18.9 - [2025/08/28]","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Fixed an issue causing <code>DoorwayPairFinder.CustomConnectionRules</code> to be reset after <code>Awake()</code> and <code>OnEnable()</code> are called, resulting in custom connection rules sometimes being lost</li> </ul>"},{"location":"changelog/#2188-20250820","title":"2.18.8 - [2025/08/20]","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Performance improvement when generating large dungeons or dungeons with many doorways</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Tiles built with ProBuilder should now correctly have their bounds calculated when not open. Previously, ProBuilder bounds would only calculate correct bounds if the Tile was placed in the scene or open in a prefab stage</li> </ul>"},{"location":"changelog/#2187-20250814","title":"2.18.7 - [2025/08/14]","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Doorways can now be marked as both an entrance and an exit at the same time, but a doorway cannot be used as an entrance if it would take the place of the only valid exit</li> </ul>"},{"location":"changelog/#2186-20250718","title":"2.18.6 - [2025/07/18]","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Fixed a <code>MissingReferenceException</code> that could sometimes happen after importing DunGen</li> <li>PlayMaker integration now correctly uses the new <code>TriggerPlacement</code> mode enum instead of the deprecated <code>PlaceTileTriggers</code> boolean</li> </ul>"},{"location":"changelog/#2185-20250713","title":"2.18.5 - [2025/07/13]","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>The analyser should now correctly handle generation failure, displaying a success rate upon completion</li> </ul>"},{"location":"changelog/#2184-20250710","title":"2.18.4 - [2025/07/10]","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Built-in culling and SECTR VIS integration now support dungeons generated attached to other dungeons</li> <li>SECTR VIS integration now caches portal meshes and disposes of them in OnDestroy()</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Fixed an issue causing changes to not be saved when adding objects to a list by dragging and dropping them in the inspector</li> </ul>"},{"location":"changelog/#2183-20250705","title":"2.18.3 - [2025/07/05]","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed an issue causing tiles to spawn in the wrong position when the dungeon root object is not at the origin</li> <li>Fixed an issue causing debug tile visualisation GameObjects to stick around after the dungeon has been generated when 'Pause Between Rooms' is greater than zero</li> </ul>"},{"location":"changelog/#2182-20250702","title":"2.18.2 - [2025/07/02]","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>The <code>Dungeon</code> class now has a reference to the <code>TileInstanceSource</code> used for tile pooling. There's now a parameterless <code>Clear()</code> function that will return all tiles to the pool and clear the dungeon</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>The generation failure report window should now correctly display an error when a required tile could not be injected, causing the dungeon generation as a whole to fail</li> <li>Fixed an issue where multiple copies of the same door prefab would be added to the <code>Dungeon</code> component's list of doors</li> <li>Fixed a build error caused by <code>DunGenSettings</code> validation using editor-only methods</li> <li>Fixed some build-only warnings</li> </ul>"},{"location":"changelog/#2181-20250617","title":"2.18.1 - [2025/06/17]","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added support for 2D tile trigger placement</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Tile injection rules can now be re-ordered and collapsed in the inspector. This has no effect on the generation process and is purely visual</li> </ul>"},{"location":"changelog/#218-20250610","title":"2.18 - [2025/06/10]","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Doorway connector and blocker prefabs can now optionally use position &amp; rotation offsets to correctly align the prefabs</li> <li>Added a new option for pooling tiles, improving performance when generating dungeons multiple times<ul> <li>Added a <code>TilePoolPreloader</code> component that can be added into the scene to spawn instances of tiles that can be saved with the level and will be used to pre-warm the tile pool</li> </ul> </li> <li>Added a <code>ITileSpawnEventReceiver</code> interface that can be implemented on any script to receive a callback when the parent tile is spawned or de-spawned. Useful for resetting state when using tile pooling</li> <li>Added <code>OnDungeonGenerationStarted</code> and <code>OnAnyDungeonGenerationStarted</code> events to the <code>DungeonGenerator</code> class</li> <li>Added a new window for displaying the stats of a generated dungeon (Window &gt; DunGen &gt; Generation Stats)</li> <li>Added functions for finding tiles by their tags to the <code>Dungeon</code> class: <code>FindTilesWithTag</code>, <code>FindTilesWithAnyTag</code>, <code>FindTilesWithAllTags</code></li> <li>The <code>Dungeon</code> class now lists all branches via the <code>Branches</code> property</li> <li>DunGen settings can now be accessed from the project settings window (Edit &gt; Project Settings...)</li> <li>Added a validation rule that warns when a tile prefab is missing a <code>Tile</code> component</li> <li>Enhanced path straightening options:<ul> <li>Settings on <code>Archetypes</code> now include an option to straighten branches in addition to or instead of the main path</li> <li>Path straightening can now also be applied to nodes in the dungeon flow graph</li> <li>There are now global settings for path straightening on the <code>DungeonFlow</code> asset. These can be optionally overridden in <code>Archetypes</code> and on Nodes in the flow graph</li> </ul> </li> <li>When the dungeon generation fails after reaching the maximum number of retries, a failure report window will now be displayed, showing all the reasons why the generation failed, and which tiles were involved. This can be turned off in the project settings</li> <li>Line segments in the dungeon flow graph can now be resized by clicking and dragging the boundary between two line segments</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>[BREAKING CHANGE]: <code>IKeySpawnable</code> has been deprecated. Please update your code to use the new <code>IKeySpawner</code> interface instead</li> <li>Tile instantiation is now also asynchronous if 'Generate Asynchronously' is enabled in the generator settings</li> <li>PauseBetweenRooms is now automatically disabled outside of the editor so it won't affect the performance of builds</li> <li>Improvements to generation performance:<ul> <li>Tile bounds are now pre-calculated in the editor to avoid performance overhead at runtime. By default, bounds are automatically recalculated each time the tile prefab is saved, but this can be turned off in the project settings. Bounds can be recalculated at any time using a new button in the Tile inspector<ul> <li>Performance improvement will scale up with the number and complexity of tile prefabs</li> </ul> </li> <li>Tiles are no longer deactivated before being destroyed</li> <li>Bounds from additional tiles that should contribute to collision avoidance are now cached at the beginning of the generation process</li> <li>Implemented a choice of broad phase for collision detection: None, Quadtree, or Spatial Hashing. NOTE: Quadtree is not recommended and currently only supports dungeons where the up vector is +Y<ul> <li>Affects the MainPath and Branching phases. Performance improvement will scale up with the number of tiles in the dungeon</li> </ul> </li> <li>Prospective doorway pairs are now sorted in a single pass, and custom connection rules are sorted once at the beginning of the generation process</li> <li>TileProxy objects are now pooled</li> <li>Various small performance improvements</li> </ul> </li> <li>The option to include sprite renderers in the bounds calculations has been moved to the global DunGen settings asset</li> <li>Collision functionality and settings have been refactored into their own classes. Settings now belong in the <code>DungeonCollisionSettings</code> class</li> <li>The Dungeon class now has a <code>TileInstantiated</code> event that is fired when a new tile is instantiated</li> <li>Updated all samples to support tile pooling</li> <li><code>DungeonGenerator</code>'s <code>GenerationStats</code> now contains information about how many of each type of tile were spawned, including how many were newly instantiated vs pulled from the pool</li> <li>Added assembly definitions for 'DunGen' and 'DunGen.Editor'</li> <li>Integrations for Unity's NavMesh Components and A* Pathfinding Project Pro no longer need to be manually extracted. They will be automatically enabled if the appropriate packages are present</li> <li>Added collapsible foldout categories to the dungeon generator inspector</li> <li>Selected node/line is now highlighted in the dungeon flow graph editor window</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Custom connection rules should now be properly reset if domain reload is disabled in the project</li> <li>Fixed an issue in the Basic Sample causing many materials to be created when generating a dungeon</li> <li>Fixed an issue where the project would lose a reference to the default doorway socket</li> <li>The Doorway component should now always correctly revert to the default socket when no other is selected</li> <li>Labels on nodes in the dungeon flow graph editor should now correctly appear black in newer versions of Unity</li> <li>Removed remaining instances of deprecated <code>FindObjectOfType</code> and <code>FindObjectsOfType</code></li> <li>Generating a dungeon attached to a manually placed tile (not spawned by DunGen) should now work as intended</li> <li>Fixed <code>NullReferenceException</code> when placing Doorways in a hierarchy with no <code>Tile</code> component</li> <li>The path straightening chance in the <code>DungeonArchetype</code> should now work as intended</li> <li>Fixed <code>NullReferenceException</code> when using empty entries in <code>LocalPropSet</code> component</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed support for versions of A* Pathfinding Project Pro before 5.0</li> <li>Removed RAIN AI integration</li> </ul>"},{"location":"changelog/#2175-20250503","title":"2.17.5 - [2025/05/03]","text":""},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Path straightening should now work as intended</li> </ul>"},{"location":"changelog/#2174-20241015","title":"2.17.4 - [2024/10/15]","text":""},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Fixed an issue that broke nesting for random prefab props</li> </ul>"},{"location":"changelog/#2173","title":"2.17.3","text":""},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>All generation steps now call the <code>OnGenerationStatusChanged</code> callback. Previously the callback was incorrectly not triggering for TileInjection, BranchPruning, and InstantiatingTiles</li> </ul>"},{"location":"changelog/#2172","title":"2.17.2","text":""},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>AStarPathfindingProjectPro adapter now correctly supports version 5.0</li> </ul>"},{"location":"changelog/#2171","title":"2.17.1","text":""},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>Fixed a null reference exception caused by trying to process a prop that had been deleted by another prop script</li> </ul>"},{"location":"changelog/#217-20240829","title":"2.17 - [2024/08/29]","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Dungeons can now be generated attached to other dungeons or even manually placed tiles in the scene using the new AttachmentSettings property on the DungeonGenerator class</li> <li>Added a new branch mode that allows users to specify the number of branches that should appear on a given section in the dungeon flow (see 'Branch Mode' in the dungeon flow settings)</li> <li>Added a new option in the archetype settings to optionally specify which tiles can be used at the beginning of branches (similar to the branch cap settings)</li> <li>DunGen can now avoid colliding with objects not placed by the dungeon generator in one of two ways:<ul> <li>Adding custom Bounds to the <code>AdditionalCollisionBounds</code> property on the DungeonGenerator class</li> <li>Providing a custom function to the <code>AdditionalCollisionsPredicate</code> property on the DungeonGenerator class</li> </ul> </li> <li>Multiple doorways can now be marked as designated potential entrances and exits, instead of just one of each</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>The <code>TilePlacementData</code> class now contains a new 'BranchId' property to allow custom code to know which branch a tile belongs to</li> <li>Added events for <code>OnGenerationComplete</code> and <code>OnAnyDungeonGenerationComplete</code> to the dungeon generator that can be used instead of the original <code>OnGenerationStatusChanged</code> if you're only interested in completion</li> <li>By default, the dungeon generator will now check for collisions against every other dungeon in the scene. This can be disabled by unchecking 'Collide All Dungeons' in the generator settings</li> <li>Replaced instances of obsolete methods (as a result, DunGen now requires Unity 2020.3 as the minimum version)<ul> <li><code>FindObjectOfType</code> -&gt; <code>FindFirstObjectByType</code></li> <li><code>FindObjectsOfType</code> -&gt; <code>FindObjectsByType</code></li> </ul> </li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>Fixed an issue causing the 'DunGen Settings' asset to not be created properly in newer versions of Unity</li> <li>Fixed a crash that could happen in the DungeonCrawler sample project when going from one scene to another</li> <li>Fixed an exception that could happen in the editor when using the culling camera when no scene cameras are present</li> <li>Fixed an issue that could sometimes cause a key to be placed inside the room being locked (or on any of the attached branches)</li> <li>Fixed an issue causing door prefabs to be removed when trying and failing to replace it with a locked door</li> <li>Fixed an issue where keys would exist inside a dungeon even if the corresponding locked doorway could not be placed</li> <li><code>Dungeon.Bounds</code> is now correctly calculated in world-space when using a dungeon root object not at the origin</li> </ul>"},{"location":"changelog/#216-20230815","title":"2.16 - [2023/08/15]","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Most lists now support dragging and dropping to add new elements (including archetypes, tile sets, props, and doorway connectors/blockers)</li> <li>All lists now support undo/redo when adding or deleting elements</li> <li>Prop processing is now significantly faster on complex dungeons with many GameObjects</li> <li>Empty GameObject entries in the LocalPropSet or RandomPrefab components will no longer be ignored and can now be used to signal that no prop should be spawned</li> <li>Added a validation rule that warns when a terrain is being used in a tile that allows rotation (Unity terrains cannot be rotated)</li> <li>Selected doorways are now checked for valid placement in the editor:<ul> <li>The doorway will be colour-coded (green = valid, orange = not placed on the edge of the tile, red = not axis-aligned)</li> <li>A red line will be drawn from the doorway to the nearest valid location</li> <li>For doorways that are incorrectly placed, there will be a button in the inspector to attempt to fix the placement issues</li> </ul> </li> <li>The dungeon validator will now warn when a doorway is not placed on the edge of the tile bounding box</li> <li>Unity NavMesh Adapter improvements<ul> <li>Added a new option to automatically calculate the start and end points of navigation links per-doorway instead of just using a pre-determined distance on either side of the doorway</li> <li>When using the \"Full Dungeon Bake\" mode, any existing NavMesh surfaces in the dungeons will now be disabled to avoid overlapping navigation meshes</li> </ul> </li> <li><code>TileConnectionRule</code> supports a new 'ConnectionDelegate' which contains more information for more complex custom connection rules. The old delegate has been marked as obsolete but will continue to function for now</li> <li>Tags are now available on tile and doorway proxy objects for easier access when writing custom connection rules in code</li> <li>Tiles now have a branch ID that can be accessed via the tile's 'Placement' property. All tiles on the same branch will share a branch ID. Tiles not on a branch will have a branch ID of -1</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>Fixed an issue where too much time was being attributed to the branch generation step. New steps for branch pruning and instantiating tile prefabs have been added for more accurate analysis</li> <li>Fixed and issue causing the 'Cull Each Child' option to not work properly with newer versions of SECTR (requires re-exporting SECTR_VIS integration package)</li> <li>Fixed a NullReferenceException when using an empty entry in the RandomPrefab component</li> <li>Fixed an issue causing the dungeon validator to incorrectly warn about doorways facing the wrong way in a tile containing a terrain</li> <li>Fixed an issue causing keys to sometimes not be able to spawn in the same room as the lock</li> <li>Key spawn points will now correctly only be used once</li> <li>Fixed an issue causing a doorway's 'LockID' to not be assigned</li> <li>Fixed a NullReferenceException caused when no valid locks could be found</li> <li>Fixed a NullReferenceException when trying to copy tags from a tile that has none assigned</li> <li>Fixed a bug causing DunGen to generate too few branches when the branch mode is set to 'Global'</li> </ul>"},{"location":"changelog/#2151-20211101","title":"2.15.1 - [2021/11/01]","text":""},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>The built-in Unity NavMesh adapter now supports providing a layer mask for any surfaces that need to be added at runtime. Existing surfaces are unaffected by this setting</li> <li>The <code>DungeonGenerator</code> class now contains a static event <code>OnAnyDungeonGenerationStatusChanged</code> which can be used without a direct reference to a given generator instance</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>Fixed an issue causing injected tiles to sometimes have their locks not spawn on the entrance doorway</li> <li>Fixed an issue resulting in an uneven distribution of branches when using the 'Global' branch mode</li> <li>Fixed an issue causing the 'Global' branch mode to sometimes result in more than the maximum number of branches being created</li> <li>Fixed an issue causing the DungenCharacter component to not correctly track the current tile if the player only partially stepped into a new tile before returning to the original</li> <li>Fixed an error caused by the DungenCharacter component re-checking tiles when a dungeon is generated in the editor</li> <li>Dungeon information (tiles, connections, tile bounds, etc) should now be properly saved when generating a dungeon in the editor</li> </ul>"},{"location":"changelog/#215-20211016","title":"2.15 - [2021/10/16]","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Injected tiles can now optionally have a locked door using the standard Lock &amp; Key system</li> <li>The dungeon flow now has an option for pruning branches based on tile tags<ul> <li>A tile at the end of a branch will be deleted based on whether it has one of the tags in the \"Branch Prune Tags\" list in the dungeon flow settings</li> <li>This setting ignores any injected tiles marked as required</li> </ul> </li> <li>Added a new <code>IDungeonCompleteReceiver</code> interface which can be implemented on any script inside a dungeon to receive a callback when the dungeon generation is complete</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Doorways now have a set of tags that can be used for custom connection logic in code using <code>DoorwayPairFinder.CustomConnectionRules</code></li> </ul>"},{"location":"changelog/#fixed_20","title":"Fixed","text":"<ul> <li>Doorways connected by the dungeon flow's random connection chance setting should now properly respect custom connection rules</li> <li>It should now once again be possible to select a different 'Count Mode' in the local prop set inspector</li> <li>Fixed an issue causing changes to sometimes not be saved when modifying the tags on a Tile component</li> </ul>"},{"location":"changelog/#214-20210619","title":"2.14 - [2021/06/19]","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Added user-defined tags that can be applied to individual tiles<ul> <li>The dungeon flow now has a \"Tile Connection Rules\" section that can be used to customise which tiles are allowed to connect based on their tags</li> <li>Tags can be accessed through code to apply more complex logic</li> </ul> </li> <li>Added a new method for applying custom logic through code to allow/disallow connections between tiles (see <code>DoorwayPairFinder.CustomConnectionRules</code>)<ul> <li>Supports making decisions based on doorways and tiles instead of just two doorway sockets</li> <li>Can be assigned priorities and chained together</li> </ul> </li> <li>Added a new NavMesh adapter for 2D dungeons<ul> <li>Can be found in 'DunGen/Integration/Unity NavMesh.unitypackage'</li> <li>Requires 2017.2 or higher</li> <li>Currently supports SpriteRenderer meshes (not colliders) and Tilemaps sprite meshes (also not colliders)</li> </ul> </li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>AdjacentRoomCulling component Improvements<ul> <li>Added IsTileVisible method and TileVisibilityChanged event</li> <li>Can now optionally ignore components that are disabled from the start</li> <li>Many methods are now marked as virtual for easier extension</li> <li>Now also culls reflection probes</li> </ul> </li> </ul>"},{"location":"changelog/#2134","title":"2.13.4","text":""},{"location":"changelog/#fixed_21","title":"Fixed","text":"<ul> <li>Fixed a compilation error in the Playmaker integration package</li> <li>Fixed an issue that allowed designated exits to be used as an entrance to the tile</li> </ul>"},{"location":"changelog/#2133","title":"2.13.3","text":""},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>[Breaking Change]: All references to <code>System.Random</code> have been replaced with a new type <code>DunGen.RandomStream</code>. Any user code that references the random number generator will need to be updated.</li> <li>The dungeon generator should now produce identical results when using the same seed even across different .NET versions</li> </ul>"},{"location":"changelog/#2132-20200813","title":"2.13.2 - [2020/08/13]","text":""},{"location":"changelog/#fixed_22","title":"Fixed","text":"<ul> <li>Fixed an error when trying to process child props that have been removed by a prop script</li> <li>When doing a full dungeon bake using Unity's NavMesh system, the old NavMesh is now correctly cleared first</li> </ul>"},{"location":"changelog/#2131-20200701","title":"2.13.1 - [2020/07/01]","text":""},{"location":"changelog/#fixed_23","title":"Fixed","text":"<ul> <li>Removed deprecated components from sample scenes to avoid warnings in Unity 2020.1</li> <li>The 'Adjacent Room Culling (Multi-Camera)' component should now work when using scriptable render pipelines, provided the project is Unity 2019.1 or higher</li> <li>The 'Adjacent Room Culling' component (non-multi-camera) now also has a 'Target Override' property to match its multi-camera counterpart, allowing it to be used in games where you want to cull around the character, not the camera (e.g. third-person or 2D)</li> <li>Fixed an issue in the Dungeon Crawler Sample that caused the NavMesh to persist between scenes</li> <li>Fixed an issue with SECTR portal culling integration that caused rooms to not be culled initially when 'Multi Camera Culling' was turned off</li> <li>Fixed an issue causing 'Doorway Connection Chance' to do nothing</li> </ul>"},{"location":"changelog/#213-20200505","title":"2.13 - [2020/05/05]","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Archetypes can now be be marked as unique. DunGen will try to ensure that unique archetypes are only used once throughout the dungeon.</li> <li>The Door component now contains a <code>DontCullBehind</code> property to allow doors to be closed without culling rooms behind it. This works for the built-in culling and the SECTR VIS integration.</li> <li>Doorway connector &amp; blocker prefabs can now all be assigned weights for more control over how frequently certain objects spawn.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Tile prefabs are now only instantiated after the entire dungeon layout is generated, resulting in much faster generation times. Tiles will still be spawned individually when generating asynchronously with a 'Pause Between Rooms' greater than zero to allow for visual debugging.</li> <li>Local Prop Set and Random Prefab props can now be nested properly. Global props should still not have other props nested inside them, but can be nested inside others.</li> <li>When using the 'Full Dungeon Bake' mode with the built-in Unity NavMesh adapter, it's now possible to use your own surfaces for more control over settings by unchecking the 'Auto-Generate Surfaces' checkbox.</li> </ul>"},{"location":"changelog/#fixed_24","title":"Fixed","text":"<ul> <li>Local prop sets now correctly work with objects attached to door connectors &amp; blockers</li> <li>The SECTR VIS integration will no longer throw an error if a door already has a SECTR_MEMBER component</li> </ul>"},{"location":"changelog/#2121-20191212","title":"2.12.1 - [2019/12/12]","text":""},{"location":"changelog/#fixed_25","title":"Fixed","text":"<ul> <li>Dungeon generator settings should now properly work with the new prefab workflow in Unity</li> <li>Fixed an issue causing the phase of a post-process step to be ignored</li> <li>Connector prefab instances now correctly have their local position reset after being parented to the doorway</li> </ul>"},{"location":"changelog/#212-20191120","title":"2.12 - [2019/11/20]","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Dungeon Crawler Sample (Extract from \"DunGen/Samples/DungeonCrawler.unitypackage\"). Requires Unity 2019.1 or higher</li> <li>Doorway sockets are no longer hard-coded and are instead assets that can be added without modifying DunGen's source code<ul> <li>Doorway size is now part of the new DoorwaySocket asset instead of being applied to each doorway instance</li> </ul> </li> <li>Doorway socket connection logic can be overridden by providing your own function to <code>DoorwaySocket.CustomSocketConnectionDelegate</code></li> <li>Added a new constraint in generator settings to enforce a minimum padding distance between unconnected tiles</li> <li>Added a new constraint in generator settings to disallow overhangs (so rooms cannot spawn above other rooms)</li> <li>Added a new icon for doorways</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>[Breaking Change]: Upgrading from older versions requires deleting the old version first. Doorways must have their sockets re-assigned using the new system. Up-direction must be re-assigned in dungeon generator settings.</li> <li>Door prefabs are now parented to their doorway objects, rather than the dungeon root</li> <li>The maximum overlap between two connected tiles can be tweaked in the dungeon generator settings</li> <li>Simplified up-vector selection</li> <li>If no socket is specified for an entry in a TileSet's locked door prefab list, the locked door can be assigned to any socket</li> <li>Assigning a prefab to a key is now optional</li> <li>Disabled doorways are no longer considered when connecting tiles together or when calculating tile bounds</li> </ul>"},{"location":"changelog/#2119-20191028","title":"2.11.9 - [2019/10/28]","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added a new built-in culling component \"AdjacentRoomCulling\"</li> <li>Added \"Full Dungeon Bake\" mode to Unity NavMesh integration which allows the entire dungeon to be baked as a single surface when generated</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Improvements to built-in basic culling camera<ul> <li>Improved performance by ~60% (3.19ms -&gt; 1.29ms in test case)</li> <li>Now optionally supports culling light sources</li> <li>Now supports culling doors</li> </ul> </li> <li>Some improved inspector tooltips</li> </ul>"},{"location":"changelog/#2118-20190805","title":"2.11.8 - [2019/08/05]","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Added an option to override the global \"Doorway Connection Chance\" on a per-tile basis</li> <li>Added an option to restrict connecting overlapping doorways to only tiles that occupy the same segment of the dungeon flow graph. This should help to prevent unintended shortcuts from appearing when this feature is used</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>The documentation has been updated to include some recent features which had mistakenly been omitted. The documentation also includes a previously missing step when setting up the Lock &amp; Key system</li> <li>An error is now logged whenever a tiles automatically calculated bounds are invalid (have a negative or zero size)</li> </ul>"},{"location":"changelog/#fixed_26","title":"Fixed","text":"<ul> <li>Automatic bounds calculation will now work properly with newer versions of ProBuilder</li> </ul>"},{"location":"changelog/#2117-20190423","title":"2.11.7 - [2019/04/23]","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>A more comprehensive validation tool has been added to help find any errors when setting up a dungeon. This can be accessed using the \"Validate\" button in the DungeonFlow asset inspector</li> <li>Added a 'Branch Mode' option to the dungeon flow allowing users to optionally specify the number of branches that should appear globally across the entire dungeon, rather than locally per-tile</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>BasicRoomCullingCamera now has an option to also cull in the editor scene view</li> <li>Improved performance of BasicRoomCullingCamera in scenes with a lot of renderers</li> <li>Foldout labels can now be clicked to expand the foldout</li> <li>The old dungeon validation is now only run inside the editor for a minor performance improvement in packaged builds</li> <li>Doorways now also draw their expected up-vector to make it clearer which way they should be facing</li> <li>Adapters (such as integration for SECTR VIS and Unity's NavMesh) will no longer fail silently if attached to a GameObject without a RuntimeDungeon component</li> <li>Creating a new DunGen asset will now allow the user to specify a file name</li> <li>Some improvements for the DungeonFlow inspector</li> </ul>"},{"location":"changelog/#2116-20190219","title":"2.11.6 - [2019/02/19]","text":""},{"location":"changelog/#changed_18","title":"Changed","text":"<ul> <li>Most DunGen components now support editing multiple selected objects</li> <li>All inspector lists are now re-orderable</li> <li>Added some in-editor tooltips to properties that didn't already have them</li> <li>The Tile and RuntimeDungeon components now also allow for editing bounds in the scene view</li> <li>There is now the option to disallow any tile repetition. This can be done on a per-tile basis or overridden globally in the dungeon generator</li> </ul>"},{"location":"changelog/#fixed_27","title":"Fixed","text":"<ul> <li>Fixed an issue preventing the dungeon generating from working until the scene/editor is restarted after finding an issue with the dungeon layout</li> <li>SECTR VIS integration will now correctly use the already calculated tile bounds instead of its own. This should prevent any gaps from forming between sectors (resulting in incorrect culling)</li> <li>Fixed an issue causing some DunGen components to not save correctly when edited in the new prefab editor in Unity 2018.3</li> <li>Undo/redo should now work consistently</li> </ul>"},{"location":"changelog/#2115-20181126","title":"2.11.5 - [2018/11/26]","text":""},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>[Breaking Change]: A* Pathfinding Project Pro integration updated to version 4.0+. If you're using an older version, you'll need to add <code>ASTAR_PATHFINDING_VERSION_3</code> to your \"Scripting Define Symbols\" in the Unity project settings</li> <li>Updated to work with the new prefab system in Unity 2018.3</li> <li>Moved demo scripts to their own namespace to avoid naming conflicts</li> <li>Small update to the 2D demo scene to include a controllable player character</li> </ul>"},{"location":"changelog/#fixed_28","title":"Fixed","text":"<ul> <li>Fixed an issue preventing the basic culling camera from culling rooms behind a closed door</li> <li>The Basic Culling Camera will now no longer incorrectly refresh the visible set of tiles every frame - this could increase performance greatly</li> <li>Fixed an issue causing the integrated basic culling to not work if the camera was spawned through code</li> </ul>"},{"location":"changelog/#2114-20180828","title":"2.11.4 - [2018/08/28]","text":""},{"location":"changelog/#fixed_29","title":"Fixed","text":"<ul> <li>The start tile should now correctly respect the transform of its root game object</li> <li>The integration for A* Pathfinding Project Pro should work correctly in Unity 5 or higher</li> <li>Off-mesh links produced for Unity's NavMesh system will now take the agent's radius into account</li> </ul>"},{"location":"changelog/#2113-20180108","title":"2.11.3 - [2018/01/08]","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Auto-calculated bounds should now ignore particle systems</li> <li>DunGen now supports setting <code>Physics.autoSyncTransforms</code> (new in Unity 2017.2) to false</li> </ul>"},{"location":"changelog/#fixed_30","title":"Fixed","text":"<ul> <li>Large tiles should no longer overlap a small amount</li> <li>The per-tile \"Allow Rotation\" and \"Allow Immediate Repeats\" options should work correctly again</li> <li>Lock &amp; key placement should now correctly be done after props are processed</li> </ul>"},{"location":"changelog/#2112-20170724","title":"2.11.2 - [2017/07/24]","text":""},{"location":"changelog/#changed_21","title":"Changed","text":"<ul> <li>The \"Basic Room Culling Camera\" component can now optionally be provided with a TargetOverride transform for third-person games</li> <li>The ArchetypeValidator will now report a warning when a TileSet contains an entry with an unassigned tile and will no longer throw an unhandled exception</li> </ul>"},{"location":"changelog/#fixed_31","title":"Fixed","text":"<ul> <li>Tiles will now correctly never appear in the dungeon layout when they have a tile weight of zero</li> </ul>"},{"location":"changelog/#2111-20170523","title":"2.11.1 - [2017/05/23]","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Tiles can now optionally designate entrance and exit doorways (available by manually adding a Tile component to your tile)</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Door prefabs will now always take on the transform of the Doorway that spawned it</li> <li>\"Allow Immediate Repeats\" now defaults to true to avoid confusion when testing DunGen with a setup that has only one tile. It's still possible to override this behaviour both globally and on a per-tile basis</li> <li>The DungeonGenerator class has a new \"Retrying\" event that is fired whenever DunGen has to retry the entire dungeon layout</li> </ul>"},{"location":"changelog/#fixed_32","title":"Fixed","text":"<ul> <li>JIT errors should no longer be thrown on platforms that require AoT compilation (such as Xbox One &amp; iOS)</li> <li>Fixed an error preventing use of the PlayMaker integration</li> <li>Fixed a rare issue that caused rooms with vertical doorways to sometimes be flipped upside-down</li> <li>Fixed an issue that caused the dungeon generator to incorrectly revisit certain statuses (Branching, PostProcessing, Complete), thus making multiple calls to the <code>OnGenerationStatusChanged</code> event</li> <li>Fixed multiple errors with the dungeon flow editor window</li> <li>Fixed an OutOfMemoryException that could occur when a tile had a weight of zero</li> </ul>"},{"location":"changelog/#211-20170414","title":"2.11 - [2017/04/14]","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Added API to DungeonGenerator for registering post-process callbacks: <code>RegisterPostProcessStep()</code> &amp; <code>UnregisterPostProcessStep()</code><ul> <li>Callbacks are invoked during DunGen's Post-Process step in order of phase (before or after built-in post-processing), then priority (highest to lowest)</li> <li>The base NavMeshAdapter class has been changed to use this method to ensure that the NavMesh is build before DunGen reports that the generation is complete when using the <code>OnGenerationStatusChanged</code> event</li> </ul> </li> <li>Added an adapter for Unity's new NavMesh system (5.6 beta)</li> <li>Added an adapter for built-in simple culling for use in interior first-person games; works best with auto-closing doors on each doorway</li> <li>Dungeon generation can now be performed asynchronously so as to avoid blocking Unity's main thread, allowing for things like animated loading screens to play while the dungeon is being generated<ul> <li>There are some new settings for runtime dungeons to control this behaviour</li> <li>The new \"Pause Between Rooms\" settings allows you to pause the generation for a number of seconds after a room is placed to visualise the generation process</li> </ul> </li> <li>Added tooltips to all dungeon generator settings</li> </ul>"},{"location":"changelog/#changed_23","title":"Changed","text":"<ul> <li>[Breaking Change]: Drastic changes from previous versions. Back up your project before upgrading. Unity 5.0+ targeted (minimum Unity 4.5+ recommended).</li> <li>Drastically changed the way DunGen appends tiles internally - it should now generate faster most of the time and practically never fail</li> <li>Culling adapters now use the same method as NavMesh adapters, they are added as components to the GameObject containing the RuntimeDungeon; moved culling code out of DungeonGenerator class</li> <li>Documentation has been completely re-written to be more modular, easier to follow, and to include features that may have been skipped over in previous versions. The documentation is now front-loaded with information to get started quickly, more advanced topics come later</li> <li>Improved the inspector for the Doorway component &amp; changed some of the terminology; it should be much easier to understand now</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>The option to use the legacy weighting system has been removed, there was no reason to use it and it's no longer possible with the new generation method anyway</li> <li>Code Cleanup:<ul> <li>Removed experimental <code>GenerateAppended()</code> method. It was never fully supported and never would have been</li> <li>Removed orphaned code for dungeon analysis window. RuntimeAnalyzer has always been the way to analyse dungeon generation</li> <li>Removed code used to generate a main path without allowing backtracking - it wasn't even exposed as an option and allowing backtracking is objectively better</li> <li>Removed visibility code from the base Tile class; visibility should be handled by culling adapters</li> <li>Removed TypeUtil &amp; AnalysisWindow</li> </ul> </li> </ul>"},{"location":"changelog/#fixed_33","title":"Fixed","text":"<ul> <li>Fixed an issue with the generation failing due to not finding matching doorways in a tile when using a custom <code>IsMatchingSocket()</code> method</li> <li>Disallowing repeated tiles should now work as intended and will now also consider branches</li> <li>Fixed a collision issue when using manually overridden tile bounds</li> <li>Fixed an issue with injected tiles on the main path marked as \"required\" not appearing occasionally</li> <li>Unused tiles deleted during the generation process should no longer contribute to the NavMesh when generating synchronously</li> </ul>"},{"location":"changelog/#2101-20161211","title":"2.10.1 - [2016/12/11]","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>It's now possible to override DunGen's automatically generated tile bounds by attaching a Tile component to the room prefab and checking the \"Override Automatic Tile Bounds\" box</li> </ul>"},{"location":"changelog/#changed_24","title":"Changed","text":"<ul> <li>All Renderer component bounds will be taken into account when calculating tile bounds now, not just MeshRenderers and (optionally) SpriteRenderers</li> </ul>"},{"location":"changelog/#fixed_34","title":"Fixed","text":"<ul> <li>Tiles created with ProBuilder should now have their bounds calculated properly and should no longer overlap</li> <li>Tile prefab's scale is now correctly handled</li> </ul>"},{"location":"changelog/#210-20161115","title":"2.10 - [2016/11/15]","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Doorways now have a priority for deciding which doorway's \"Door Prefab\" should be chosen</li> <li>Added an option to specify which layer the tile trigger volume is placed on (Defaults to \"Ignore Raycasts\", only effective if \"Place Tile Triggers\" is checked)</li> <li>Added a DungeonFlowBuilder helper class to assist with creating a dungeon flow graph through code</li> <li>Added a new \"count mode\" to the local prop set script which allows the number of props to change based on the tile's position in the dungeon layout</li> </ul>"},{"location":"changelog/#changed_25","title":"Changed","text":"<ul> <li>\"Ignore Sprite Bounds\" in the dungeon generation settings is now unchecked by default</li> </ul>"},{"location":"changelog/#fixed_35","title":"Fixed","text":"<ul> <li>Fixed an issue with the 2D demo scene which caused tiles to overlap</li> <li>\"Avoid Door Prefab Rotation?\" for doorways should now be set properly</li> <li>Door prefabs should now always be cleaned up correctly</li> <li>Auto-placed trigger volumes for tiles no longer sometimes have negative sizes</li> <li>Fixed an issue with the SECTR VIS integration that was causing door states to not correctly update</li> <li>Fixed an error that occurred when trying to place a lock on a doorway that was already locked</li> <li>Fixed an issue that was incorrectly allowing assets to be selected in the LocalPropSet component</li> </ul>"},{"location":"changelog/#291-20160418","title":"2.9.1 - [2016/04/18]","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>There are now options to avoid rotating Door and Blocker prefabs placed by the Doorway component</li> </ul>"},{"location":"changelog/#changed_26","title":"Changed","text":"<ul> <li>Dungeon generation will fail much less frequently, especially when imposing constraints such as fixed tile rotations</li> <li>In the event DunGen does fail (editor only; at runtime, DunGen will keep trying indefinitely), points-of-failure will be listed to give a better idea of the cause</li> </ul>"},{"location":"changelog/#fixed_36","title":"Fixed","text":"<ul> <li>Fixed an error causing the \"Allow Tile Rotation\" override to not work properly</li> <li>Fixed an issue causing nodes in the Dungeon Flow to be un-selectable if placed over the top of the Start or Goal nodes</li> <li>Fixed an issue causing doorways from a previous dungeon to be considered when trying to connect overlapping doorways</li> <li>Fixed an ambiguous reference to <code>TooltipAttribute</code> when using PlayMaker integration with newer versions of Unity</li> </ul>"},{"location":"changelog/#29-20160403","title":"2.9 - [2016/04/03]","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>The <code>Dungeon</code> class now has a <code>Bounds</code> variable which gives the bounding box of the entire dungeon layout</li> <li>A root GameObject can now be chosen when using the RuntimeDungeon component. If none is specified, it will default to the old behaviour of creating a new root named \"Dungeon\"</li> <li>RandomPrefab props now have options for keeping the spawned prefab's position or rotation as an offset. Previously, spawned prefabs always snapped into position and ignored the prefab's transform (this is still the default behaviour)</li> <li>Added integration for generating navigation meshes with both RAIN and A* Pathfinding Project Pro</li> <li>Added an option to disable the trigger volumes DunGen places around each tile. If disabled, the DungenCharacter component won't receive events when moving between rooms</li> </ul>"},{"location":"changelog/#changed_27","title":"Changed","text":"<ul> <li>Reverted the ProBuilder support changes made in 2.8.0 - these are no longer necessary</li> <li>The utility function <code>UnityUtil.CalculateObjectBounds()</code> now ignores trigger colliders by default. Room bounds should no longer encompass any trigger colliders</li> <li>Moved <code>TypeUtil</code> class to the editor folder as it was causing issues when trying to build for Windows Store (and possibly other platforms)</li> </ul>"},{"location":"changelog/#fixed_37","title":"Fixed","text":"<ul> <li>Fixed an error in the runtime analyser</li> <li>Fixed errors when using custom doorway socket connection logic</li> </ul>"},{"location":"changelog/#28-20160111","title":"2.8 - [2016/01/11]","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>DunGen now supports tiles made with ProBuilder</li> </ul>"},{"location":"changelog/#changed_28","title":"Changed","text":"<ul> <li>Tiles will now maintain their proper weights across multiple TileSets. The old behaviour can be reactivated using the \"Use Legacy Weighting\" option in the dungeon generator settings</li> </ul>"},{"location":"changelog/#fixed_38","title":"Fixed","text":"<ul> <li>DunGen will no longer throw an ArgumentOutOfRangeException if a GameObject containing a Doorway component is disabled</li> <li>Fixed an error when trying to build a project with SECTR integration</li> <li>Fixed a stack overflow exception that occurred when no Tile matched the requirements for the next room in the layout</li> <li>The scale of Tile prefabs will no longer be reset before being placed by the generator</li> </ul>"},{"location":"changelog/#27-20151024","title":"2.7 - [2015/10/24]","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Injected tiles can now be marked as required. If a required tile is not present at the end of the branch path stage, the generation will fail (and retry until the layout is successfully generated or until the maximum number of failed attempts is reached)</li> <li>Added a new \"Length Multiplier\" option to the dungeon generator. The main path length of the output dungeon will be multiplied by this number. Allows for dungeon length to be altered dynamically at runtime</li> <li>Added support for PlayMaker actions for generating and clearing dungeon layouts</li> </ul>"},{"location":"changelog/#changed_29","title":"Changed","text":"<ul> <li>The dungeon generator will now wait one frame before changing its status to \"Complete\" to ensure all unused GameObjects are properly destroyed first</li> <li>SECTR VIS culling is now easier to enable. Just unpack \"DunGen/Integration/SECTR_VIS.unitypackage\" and select \"SECTR VIS\" from the list of portal culling solutions in the dungeon generator settings. It's now also much easier to integrate your own portal culling solution; just derive a new type from PortalCullingAdapter and implement its abstract methods.</li> <li>Portal culling will now also automatically handle doors placed by DunGen so that rooms are culled when the connecting door is closed - as a result, door objects are now parented to the dungeon root rather than their doorway. There is now a Door component which will automatically be added to door prefabs placed by DunGen. This component includes information about which doorways and tiles it is connected to and has a IsOpen property which is used to turn portals on or off when used with portal culling</li> <li>As a result of the new culling changes, door objects are now parented to the dungeon root, rather than their doorway</li> <li>Doors placed by the Lock &amp; Key system are now considered the same as a door prefab and so will also benefit from the above</li> </ul>"},{"location":"changelog/#fixed_39","title":"Fixed","text":"<ul> <li>Fixed an issue that was causing dungeons to not generate properly when <code>Generate()</code> was called from a physics trigger/contact</li> <li>Fixed an error that caused DunGen to try to place locks &amp; keys using a DungeonFlow without a KeyManager assigned</li> <li>Tiled placed using the tile injection system should now correctly make use of their full range of possible spawn locations</li> <li>Injected tiles should no longer occasionally overwrite tiles placed by a node in the DungeonFlow</li> </ul>"},{"location":"changelog/#26-20150715","title":"2.6 - [2015/07/15]","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Tiles can now be \"injected\" into DunGen before randomization occurs. Injection delegates can be added to the generator's <code>TileInjectionMethods</code> property</li> <li>Tile injection for simple cases can be done through the DungeonFlow inspector. No code required.</li> <li>There's now a \"Overwrite Existing?\" option when generating dungeons in the editor</li> <li>Doorways now have a \"Hide Conditional Objects?\" option which hides all GameObjects in the \"Add when in use\" and \"Add when NOT in use\" lists. For the purpose of reducing clutter at design-time - has no effect on the runtime results</li> <li>Doorways now have a \"Blocker Prefabs\" list which works similarly to the existing \"Door Prefabs\" list, except with doorways that are not in use. Allows you to define blocking objects without placing them in the tile first, if that's your preferred workflow</li> </ul>"},{"location":"changelog/#changed_30","title":"Changed","text":"<ul> <li>All object lists now report how many objects they contain</li> </ul>"},{"location":"changelog/#fixed_40","title":"Fixed","text":"<ul> <li>Fixed an issue that sometimes caused tiles to not be cleaned up correctly in editor-built dungeons, resulting in what looked like overlapping tiles</li> </ul>"},{"location":"changelog/#255-20150613","title":"2.5.5 - [2015/06/13]","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li>Both \"Allow Immediate Repeats\" and \"Allow Tile Rotation\" now have optional global overrides that can be set in the dungeon generator</li> </ul>"},{"location":"changelog/#changed_31","title":"Changed","text":"<ul> <li>\"Allow Immediate Repeats\" can now be specified per-tile and is now set to false by default</li> </ul>"},{"location":"changelog/#fixed_41","title":"Fixed","text":"<ul> <li>Fixed an issue causing Tile trigger volumes to sometimes be incorrectly oriented</li> <li>Fixed a bug which lead to SECTR portals not being removed when calling the <code>Generate()</code> function multiple times (like when using the analyser)</li> <li>Fixed some camera related bugs in the demo scene</li> </ul>"},{"location":"changelog/#254-20150411","title":"2.5.4 - [2015/04/11]","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>The <code>DungeonGenerator</code> class now has a <code>DetachDungeon</code> method allowing you to \"tear-off\" the dungeon from the generator so that it is not overwritten next time <code>Generate()</code> is called</li> <li>[EXPERIMENTAL] The <code>DungeonGenerator</code> class now has a <code>GenerateAppended</code> method which will generate a new dungeon appended to a previous dungeon that you specify. NOTE: This is entirely experimental and NOT supported functionality; dungeons generated in this manner will likely overlap or fail depending on whether allowIntersection is set. You'll have to decide how/if this is handled when it occurs. This is mostly in place as a starting point for those of you who want to implement infinite dungeons - but it needs additional logic (likely game-specific) to work as a complete solution.</li> <li>Doorway components now have a <code>ConnectedDoorway</code> variable</li> <li>Tiles now have some methods of getting/checking adjacent Tiles</li> <li>Tiles now contain a BoxCollider trigger component. There's a new DungenCharacter component which handles information about which Tile it's currently in (with events fired when switching tiles)</li> </ul>"},{"location":"changelog/#changed_32","title":"Changed","text":"<ul> <li>DunGen is using a new method for socketing doorways together which is more robust. Doorways can now be aligned vertically (for stairwells, for example)</li> </ul>"},{"location":"changelog/#fixed_42","title":"Fixed","text":"<ul> <li>The Lock &amp; Key system will correctly also place locks on doorways that don't have a prefab applied to them</li> </ul>"},{"location":"changelog/#253-20150210","title":"2.5.3 - [2015/02/10]","text":""},{"location":"changelog/#changed_33","title":"Changed","text":"<ul> <li>The <code>Doorway</code> class is now properly defined under the namespace \"DunGen\" which should help with any naming conflicts</li> <li>Minor changes to make the demo scene compatible with Unity 5.0</li> </ul>"},{"location":"changelog/#fixed_43","title":"Fixed","text":"<ul> <li>DunGen should no longer try to apply a lock to the same door twice, causing an exception to be thrown</li> <li>Doorways with no possible \"locked door prefab\" will no longer be considered when adding locks</li> <li>In-editor dungeons will once again generate correctly</li> <li>Dungeons should now be generated in the local coordinate space of its root GameObject, rather than at the world-space origin</li> <li>Fixed an issue causing a branch tile's <code>NormalizedPathDepth</code> to be calculated incorrectly, resulting in errors in Unity 5</li> </ul>"},{"location":"changelog/#252-20141229","title":"2.5.2 - [2014/12/29]","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>Added a Straighten slider to the DungeonArchetype that controls the likelihood that the main path generated will be a straight line (thanks to Binary42)</li> <li>Multiple keys can now be spawned for a single lock. In the KeyManager asset, each key has a \"Keys per Lock\" value</li> </ul>"},{"location":"changelog/#changed_34","title":"Changed","text":"<ul> <li>Users should notice a large improvement in success rate when generating dungeons</li> <li>DunGen will keep trying until it succeeds when the project is built (can still fail in the editor as a safety net to prevent infinite loops for invalid dungeons)</li> <li>Users should notice a further large improvement in success rate when generating dungeons; in addition to shorter generation times (thanks to ashwinFEC)</li> </ul>"},{"location":"changelog/#fixed_44","title":"Fixed","text":"<ul> <li>Fixed an issue causing bounding boxes to sometimes be calculated incorrectly</li> <li>Doorways should no longer have multiple door prefabs assigned to them if the doorways were connected by overlapping</li> <li>Doorways with different sockets will no longer be connected when overlapping</li> <li>DunGen should now retry to place a Tile when none of those in the TileSet have a socket of the correct type</li> <li>DunGen should now correctly try to add the specified number of locked doors to a dungeon segment. NOTE: This still rarely produces desired results</li> </ul>"},{"location":"changelog/#251-20141219","title":"2.5.1 - [2014/12/19]","text":""},{"location":"changelog/#fixed_45","title":"Fixed","text":"<ul> <li>Fixed an issue causing RandomPrefabs to not inherit their parent's rotation</li> <li>RandomPrefabs will now correctly be added when nested inside another RandomPrefab</li> <li>Door prefabs will now correctly be added to open doorways</li> </ul>"},{"location":"changelog/#25-20141004","title":"2.5 - [2014/10/04]","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Added an option to reduce the frequency that duplicate rooms are being placed right next to each other. Un-checking \"Allow Immediate Repeats\" in the dungeon generator settings will enable this behaviour.</li> <li>Added a button to the Local Prop Set inspector that allows for all currently selected GameObjects to be added to the list at once.</li> </ul>"},{"location":"changelog/#fixed_46","title":"Fixed","text":"<ul> <li>Fixed a bug causing the bounding box of some rooms to be incorrect once rotated by DunGen.</li> <li>Fixed a bug causing the ChosenSeed variable to be set incorrectly after a failed generation attempt.</li> </ul>"},{"location":"changelog/#242","title":"2.4.2","text":""},{"location":"changelog/#changed_35","title":"Changed","text":"<ul> <li>Doorways no longer have to be on the very edge of a room's bounds. DunGen will calculate the bounds as usual, then collapse them to fit the doorways where necessary.</li> </ul>"},{"location":"changelog/#241","title":"2.4.1","text":""},{"location":"changelog/#fixed_47","title":"Fixed","text":"<ul> <li>Fixed a bug preventing the seed from being set manually</li> <li>Fixed a bug causing branching depth to not behave as expected</li> </ul>"},{"location":"changelog/#24-20140706","title":"2.4 - [2014/07/06]","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>Added preliminary support for 2D dungeons. It's now possible to change the up-axis for dungeon generation inside the dungeon generator settings. 2D support hasn't been thoroughly tested yet but it is feature-complete.</li> </ul>"},{"location":"changelog/#231-20140529","title":"2.3.1 - [2014/05/29]","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>DunGen now supports SECTR portal culling. If you have the SECTR VIS extension, you will have automatic portal culling applied to your runtime and in-editor dungeons with minimal setup.</li> <li>Added door prefabs</li> </ul>"},{"location":"changelog/#22-20140517","title":"2.2 - [2014/05/17]","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li>Added a new analysis tool that generates a set number of copies of a dungeon and presents detailed results such as success rate, average generation time, etc</li> </ul>"},{"location":"changelog/#changed_36","title":"Changed","text":"<ul> <li>It's no longer a requirement to make sure the prefab's position is set to (0,0,0) - not doing so will no longer cause the tile's position to be offset in the dungeon</li> </ul>"},{"location":"changelog/#fixed_48","title":"Fixed","text":"<ul> <li>Fixed an issue that caused the timings returned by the generation stats to be inaccurate when the dungeon fails to generate the first time</li> </ul>"},{"location":"changelog/#21-20140502","title":"2.1 - [2014/05/02]","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li>Lock Key system</li> <li>You can tell DunGen to connect doorways that overlap but were otherwise not connected during the generation process</li> </ul>"},{"location":"changelog/#20-20140423","title":"2.0 - [2014/04/23]","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li>Implemented the dungeon flow editor. You can now control the flow of your procedural dungeons including the ability to add specific rooms at points on the main path</li> <li>Introduced two new types of asset: Dungeon Archetype and Tile Set which should allow for far more control when building a dungeon</li> </ul>"},{"location":"changelog/#changed_37","title":"Changed","text":"<ul> <li>[Breaking Change]: Complete rewrite from v1.x. Significant code and workflow changes.</li> <li>Homogenised object weights. Weights for all objects (tiles/rooms and all prop types) now contain a main path weight, a branch path weight, and a depth scale curve</li> <li>A lot of terminology and naming was changed, there's less ambiguity now when it comes to identifying key components of DunGen</li> <li>Cleaned up the UI a lot</li> </ul>"},{"location":"changelog/#101-20140313","title":"1.0.1 - [2014/03/13]","text":""},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li>Added some height-varying rooms to the demo project to demonstrate multi-floor dungeons</li> <li>Added the option to generate a dungeon in the editor instead of at runtime</li> </ul>"},{"location":"changelog/#10-20140307","title":"1.0 - [2014/03/07]","text":"<p>Initial Version</p>"},{"location":"advanced-features/","title":"Advanced Features: Overview","text":"<p>Once you're comfortable with the Core Concepts of Tiles, Tile Sets, Archetypes, and the basic Dungeon Flow, you can begin exploring DunGen's more advanced capabilities. This section covers features that allow for greater control, deeper integration with your game systems, and more complex procedural outcomes.</p> <p>These features build upon the foundation established earlier, enabling you to:</p> <ul> <li>Add significant visual variety without necessarily creating more unique Tile prefabs.</li> <li>Implement gameplay mechanics like locked doors and keys.</li> <li>Exercise fine-grained control over tile placement and connectivity.</li> <li>Hook into the generation process with your own custom code.</li> <li>Attach new dungeons dynamically to existing ones.</li> </ul> <p>Build Upon Core Concepts</p> <p>While powerful, these features generally assume a working knowledge of the basic DunGen workflow. If you haven't already, make sure you're familiar with the topics covered in the Getting Started and Core Concepts sections.</p> <p>Explore the Advanced Features:</p> <ul> <li>Props for Variety: Learn how to use Local Prop Sets, Random Prefabs, and Global Props to dynamically add or remove objects within your tiles, increasing visual interest and randomness.</li> <li>Doors: Go beyond simple blockers/connectors. Understand the <code>Door</code> component placed on spawned door prefabs and how it interacts with other systems like culling and pathfinding.</li> <li>Lock &amp; Key System: Implement locked doors and corresponding keys within your dungeon layouts using DunGen's integrated system and its C# interfaces.</li> <li>Injecting Special Tiles: Force specific tiles or tile types to appear at certain points or under certain conditions within the dungeon layout, using either the Inspector or custom code.</li> <li>Tile Connection Rules: Define explicit rules, using Tags or code, to control precisely which types of tiles are allowed (or forbidden) to connect to each other.</li> <li>Generating Attached Dungeons: Learn how to procedurally generate a new dungeon layout that connects seamlessly to a specific doorway in an already existing tile (either manually placed or part of a previous generation).</li> <li>Runtime Events &amp; Code Execution: Execute your own custom C# logic at specific points during or after the dungeon generation process.</li> <li>Custom Post-Processing: Add your own major steps to DunGen's generation pipeline, useful for integrating complex third-party systems or custom analysis.</li> <li>DunGen Character Component: Use this simple helper component to easily track when a player (or any object) moves between different Tiles in the generated dungeon.</li> </ul> <p>Dive into these topics to leverage the full potential of DunGen and create truly unique and dynamic procedural environments.</p>"},{"location":"advanced-features/additional-collisions/","title":"Advanced Features: Avoiding Collisions with Scene Objects","text":"<p>By default, DunGen only checks for collisions between the Tiles it is currently placing within the same generation process. It isn't inherently aware of other objects you might have manually placed in your scene (like important landmarks, puzzle elements, or structural pillars). This can lead to generated dungeons overlapping or intersecting with these crucial scene elements.</p> <p>DunGen provides two primary methods, implemented via code, to tell the generator about additional areas it should avoid colliding with.</p>"},{"location":"advanced-features/additional-collisions/#method-1-additional-bounding-boxes","title":"Method 1: Additional Bounding Boxes","text":"<p>This is the simpler approach for defining basic \"keep-out\" zones. You provide DunGen with a list of pre-defined <code>Bounds</code> objects representing volumes in world space that generated Tiles should not overlap.</p> <ul> <li>Concept: Define one or more invisible, axis-aligned rectangular boxes around your important scene objects. DunGen will treat these boxes as obstacles during its collision checks.</li> <li> <p>Implementation:</p> <ol> <li>You need access to the <code>DungeonGenerator</code> instance used by your <code>Runtime Dungeon</code> component. Typically, you get this in <code>Awake</code> or <code>Start</code> in a script attached to the same GameObject as the <code>Runtime Dungeon</code>.</li> <li>The <code>DungeonGenerator</code> has a public property: <code>CollisionSettings</code>, which in turn has an <code>AdditionalCollisionBounds</code> property (a <code>List&lt;Bounds&gt;</code>).</li> <li>Create new <code>Bounds</code> objects (defining their <code>center</code> and <code>size</code>) that encompass the areas you want to protect.</li> <li>Add these <code>Bounds</code> objects to the <code>AdditionalCollisionBounds</code> list before DunGen starts generating.</li> </ol> </li> <li> <p>Example Code:</p> <pre><code>using UnityEngine;\nusing DunGen;\n\npublic class SceneCollisionSetup : MonoBehaviour\n{\n    // Optional: Assign important scene objects in the Inspector\n    // public Transform importantPillar;\n    // public Collider importantStructureCollider;\n\n    private void Awake()\n    {\n        // Get the Runtime Dungeon component (assuming this script is on the same GameObject)\n        var runtimeDungeon = GetComponent&lt;RuntimeDungeon&gt;();\n\n        if (runtimeDungeon != null)\n        {\n            var collisionSettings = runtimeDungeon.Generator.CollisionSettings;\n\n            // --- Example 1: Define a specific volume ---\n            Bounds forbiddenZone = new Bounds(\n                new Vector3(10, 0, 0), // Center of the zone\n                new Vector3(20, 10, 20) // Total size of the zone\n            );\n            collisionSettings.AdditionalCollisionBounds.Add(forbiddenZone);\n\n            // --- Example 2: Use the bounds of an existing Collider ---\n            // if (importantStructureCollider != null)\n            // {\n            //     collisionSettings.AdditionalCollisionBounds.Add(importantStructureCollider.bounds);\n            // }\n\n            Debug.Log(\"Added custom collision bounds to DunGen Generator.\");\n        }\n        else\n        {\n            Debug.LogError(\"RuntimeDungeon or its Generator not found!\");\n        }\n    }\n}\n</code></pre> </li> <li> <p>Limitations: This method only works with axis-aligned bounding boxes. It might protect a larger area than necessary for complex or rotated objects.</p> </li> </ul>"},{"location":"advanced-features/additional-collisions/#method-2-custom-collision-function-predicate","title":"Method 2: Custom Collision Function (Predicate)","text":"<p>For more complex collision logic or checking against specific objects without relying on simple bounding boxes, you can provide DunGen with a custom function (a predicate).</p> <ul> <li>Concept: You define a function that DunGen calls every time it considers placing a Tile. This function receives information about the potential Tile's bounds and returns <code>true</code> if the placement should be prevented (collision detected) or <code>false</code> if the placement is allowed.</li> <li> <p>Implementation:</p> <ol> <li>Access the <code>DungeonGenerator</code> instance as described in Method 1 and get its <code>CollisionSettings</code> property.</li> <li>The <code>DungeonCollisionSettings</code> class has a public property: <code>AdditionalCollisionsPredicate</code>. This expects a delegate of type <code>AdditionalCollisionsDelegate</code>.</li> <li>Create a function in your script that matches the required signature: <code>bool YourFunctionName(Bounds potentialTileBounds, bool isTileCollidingWithDungeon)</code>.</li> <li>Assign your function to the <code>AdditionalCollisionsPredicate</code> property before generation starts.</li> </ol> </li> <li> <p>Delegate Signature Explained:</p> <ul> <li><code>Bounds potentialTileBounds</code>: The world-space AABB of the Tile that DunGen is considering placing.</li> <li><code>bool isTileCollidingWithDungeon</code>: A boolean indicating if DunGen's internal checks have already detected a collision between this potential Tile and other Tiles within the currently generating dungeon. This is useful to avoid redundant checks or to allow your custom logic to override DunGen's internal check if needed (though usually you'll want to respect it).</li> <li>Return Value:<ul> <li><code>true</code>: Collision detected by your custom logic. Prevent placement.</li> <li><code>false</code>: No collision detected by your custom logic. Allow placement.</li> </ul> </li> </ul> </li> <li> <p>Example Code:</p> <pre><code>using UnityEngine;\nusing DunGen;\n\npublic class SceneCollisionSetupCustom : MonoBehaviour\n{\n    // Define which layers to check against in the Inspector\n    public LayerMask CollisionCheckLayer;\n\n    private RuntimeDungeon runtimeDungeon;\n\n\n    private void Awake()\n    {\n        runtimeDungeon = GetComponent&lt;RuntimeDungeon&gt;();\n\n        if (runtimeDungeon != null)\n        {\n            var collisionSettings = runtimeDungeon.Generator.CollisionSettings;\n\n            collisionSettings.AdditionalCollisionsPredicate = ShouldTilePlacementBeBlocked;\n            Debug.Log(\"Assigned custom collision predicate to DunGen Generator.\");\n        }\n    }\n\n    private void OnDestroy()\n    {\n        if (runtimeDungeon != null)\n        {\n            var collisionSettings = runtimeDungeon.Generator.CollisionSettings;\n            collisionSettings.AdditionalCollisionsPredicate = null;\n            Debug.Log(\"Removed custom collision predicate from DunGen Generator.\");\n        }\n    }\n\n    // Function matching the AdditionalCollisionsDelegate signature\n    private bool ShouldTilePlacementBeBlocked(Bounds potentialTileBounds, bool isTileCollidingWithDungeon)\n    {\n        // 1. Respect DunGen's internal collision check first\n        if (isTileCollidingWithDungeon)\n        {\n            return true; // Already colliding with another generated tile, definitely block.\n        }\n\n        // 2. Perform your custom check (e.g., check for overlap with specific layers)\n        Collider[] overlaps = Physics.OverlapBox(\n            potentialTileBounds.center,\n            potentialTileBounds.extents, // OverlapBox uses extents (half-size)\n            Quaternion.identity,        // AABBs are not rotated\n            CollisionCheckLayer         // Check only against specified layers\n        );\n\n        // 3. Decide based on the custom check\n        if (overlaps.Length &gt; 0)\n        {\n            // Optional: Add more logic here, e.g., ignore triggers, check specific tags...\n            // For now, any overlap on the specified layer blocks placement.\n            // Debug.Log($\"Custom collision detected for tile at {potentialTileBounds.center}\");\n            return true; // Found an object on the collision layer within the bounds, block placement.\n        }\n\n        // 4. No collision found by DunGen or custom logic\n        return false; // Allow placement.\n    }\n}\n</code></pre> </li> <li> <p>Flexibility: This method is much more powerful. You can implement complex checks: query specific objects, use <code>Physics.OverlapBox</code>, <code>Physics.CheckSphere</code>, check tags, ignore triggers, etc.</p> </li> </ul>"},{"location":"advanced-features/additional-collisions/#choosing-a-method","title":"Choosing a Method","text":"<ul> <li>Use Additional Bounding Boxes for simple, rectangular keep-out zones around non-rotated objects. It's easier to set up.</li> <li>Use the Custom Collision Function for more precise checks, handling complex shapes, checking against specific layers or tags, or implementing any custom collision logic your project requires.</li> </ul> <p>Remember to apply these settings in <code>Awake</code> or <code>Start</code> in a script that runs before the <code>Runtime Dungeon</code> component attempts to generate the dungeon (e.g., if generating on start).</p>"},{"location":"advanced-features/attached-dungeons/","title":"Advanced Features: Generating Attached Dungeons","text":"<p>Typically, DunGen generates a dungeon based purely on the rules defined in the Dungeon Flow, starting from the world origin. However, you might need to generate a dungeon that physically connects to an existing piece of geometry in your scene.</p> <p>This is useful for scenarios like:</p> <ul> <li>Connecting a procedurally generated area (like a mine or cave system) to a static, hand-designed part of your level (like a town entrance).</li> <li>Dynamically spawning a new dungeon section attached to a previously generated one.</li> <li>Starting generation from a specific, manually placed entrance Tile.</li> </ul> <p>DunGen allows this through the <code>AttachmentSettings</code> property on the <code>DungeonGenerator</code> class. This is configured entirely through code before triggering the generation process.</p>"},{"location":"advanced-features/attached-dungeons/#the-attachmentsettings-class","title":"The <code>AttachmentSettings</code> Class","text":"<p>Before initiating dungeon generation via code, you can create an instance of the <code>DunGen.AttachmentSettings</code> class and assign it to <code>RuntimeDungeon.Generator.AttachmentSettings</code>. This class tells DunGen where and how to attach the start of the new dungeon layout.</p> <p>There are two primary ways to specify the attachment point:</p>"},{"location":"advanced-features/attached-dungeons/#1-attaching-to-a-tile","title":"1. Attaching to a Tile","text":"<p>You can provide a reference to an existing <code>Tile</code> component in your scene. DunGen will then attempt to attach the new dungeon to one of the <code>Doorway</code> components found on that Tile.</p> <ul> <li>How it works: DunGen randomly selects an available <code>Doorway</code> on the target <code>Tile</code>. If the initially chosen doorway is blocked (e.g., by scene geometry or another tile), DunGen will keep trying other available doorways on that same <code>Tile</code> until it finds a valid connection point or runs out of options.</li> <li>Constructor/Usage: You typically instantiate <code>AttachmentSettings</code> by passing the target <code>Tile</code> reference:     <pre><code>RuntimeDungeon runtimeDungeon;//... Get reference to the existing component\nTile targetTile;//... Get reference to the existing component\n\nvar settings = new DunGen.AttachmentSettings(targetTile);\nruntimeDungeon.Generator.AttachmentSettings = settings;\n</code></pre></li> <li>Use Case: Useful when you want to connect to a specific room or prefab already placed in the scene, but you don't need to dictate the exact doorway used for the connection.</li> </ul>"},{"location":"advanced-features/attached-dungeons/#2-attaching-to-a-specific-doorway","title":"2. Attaching to a Specific Doorway","text":"<p>For more precise control, you can provide a reference directly to a specific <code>Doorway</code> component on an existing Tile.</p> <ul> <li>How it works: DunGen will attempt to attach the start of the new dungeon only to the specified <code>Doorway</code>.</li> </ul> <p>Warning</p> <p>If you provide a specific <code>Doorway</code>, DunGen will not try other doorways on the same tile if the chosen one is blocked or invalid for attachment. It's your responsibility to ensure the provided <code>Doorway</code> is positioned correctly and has clear space for the new dungeon to generate outwards from it. If the connection fails at this specific doorway, the dungeon generation might fail entirely.</p> <ul> <li>Constructor/Usage: You typically instantiate <code>AttachmentSettings</code> by passing the target <code>Doorway</code> reference:     <pre><code>RuntimeDungeon runtimeDungeon;//... Get reference to the existing component\nDoorway targetDoorway;//... Get reference to the existing component\n\nvar settings = new DunGen.AttachmentSettings(targetDoorway);\nruntimeDungeon.Generator.AttachmentSettings = settings;\n</code></pre></li> <li>Use Case: Ideal when you need the dungeon to connect at a very specific point on an existing tile, like a pre-defined exit archway.</li> </ul>"},{"location":"advanced-features/attached-dungeons/#code-examples","title":"Code Examples","text":"<p>Here are a collection of basic example scripts demonstrating how to set up attached generation. For each example, you would:</p> <ol> <li>Attach the script to a GameObject in your scene.</li> <li>Assign the reference to your <code>RuntimeDungeon</code> component in the inspector.</li> <li>Call the <code>GenerateAttached()</code> method.</li> </ol> Continue from the previous dungeon <p>In this example, we will generate a new dungeon attached to the last tile on the main path (the Goal) of the previous dungeon that was generated by the <code>RuntimeDungeon</code> component.</p> ContinueDungeon.cs<pre><code>public class ContinueDungeon : MonoBehaviour\n{\n    // The dungeon generator to use for generating the new dungeon. Set in inspector\n    public RuntimeDungeon RuntimeDungeon;\n\n    public void GenerateAttached()\n    {\n        var previousDungeon = RuntimeDungeon.Generator.CurrentDungeon;\n\n        if (previousDungeon != null)\n        {\n            var lastTile = previousDungeon.MainPathTiles[previousDungeon.MainPathTiles.Count - 1];\n            RuntimeDungeon.Generator.AttachmentSettings = new DungeonAttachmentSettings(lastTile);\n            RuntimeDungeon.Generate();\n        }\n        else\n            Debug.LogError(\"No previous dungeon found to attach to.\");\n    }\n}\n</code></pre> Attach to a random Tile from the previous dungeon <p>In this example, we will generate a new dungeon attached to a random tile of the previous dungeon that was generated by the <code>RuntimeDungeon</code> component.</p> AttachToRandomTile.cs<pre><code>public class AttachToRandomTile : MonoBehaviour\n{\n    // The dungeon generator to use for generating the new dungeon. Set in inspector\n    public RuntimeDungeon RuntimeDungeon;\n\n    public void GenerateAttached()\n    {\n        var previousDungeon = RuntimeDungeon.Generator.CurrentDungeon;\n\n        if (previousDungeon != null)\n        {\n            // Find all tiles that have unused doorways\n            var possibleTiles = previousDungeon.AllTiles\n                .Where(x =&gt; x.UnusedDoorways.Any());\n\n            if (possibleTiles.Any())\n            {\n                // Pick a Tile at random\n                var chosenTile = possibleTiles.ElementAt(UnityEngine.Random.Range(0, possibleTiles.Count()));\n\n                // Generate a new dungeon attached to the chosen tile\n                RuntimeDungeon.Generator.AttachmentSettings = new DungeonAttachmentSettings(chosenTile);\n                RuntimeDungeon.Generate();\n            }\n            else\n                Debug.LogError(\"No tiles with unused doorways found in the previous dungeon.\");\n        }\n        else\n            Debug.LogError(\"No previous dungeon found to attach to.\");\n    }\n}\n</code></pre> Attach to a specific Doorway <p>In this example, we generate a new dungeon attached to a specific <code>Doorway</code> component that exists in the scene.</p> AttachToSpecificDoorway.cs<pre><code>public class AttachToSpecificDoorway : MonoBehaviour\n{\n    // The dungeon generator to use for generating the new dungeon. Set in inspector\n    public RuntimeDungeon RuntimeDungeon;\n\n    // The existing doorway component to attach to. Set in inspector\n    public Doorway SpecificDoorway;\n\n\n    public void GenerateAttached()\n    {\n        RuntimeDungeon.Generator.AttachmentSettings = new DungeonAttachmentSettings(SpecificDoorway);\n        RuntimeDungeon.Generate();\n    }\n}\n</code></pre>"},{"location":"advanced-features/character-component/","title":"Advanced Features: DunGen Character Component","text":"<p>The DunGen Character component is a simple helper utility provided with DunGen that makes it easy to detect when a specific GameObject (like your player character or an important NPC) moves from one generated Tile to another.</p>"},{"location":"advanced-features/character-component/#what-it-does","title":"What it Does","text":"<ul> <li>It monitors the Tile that the GameObject it's attached to currently occupies.</li> <li>When the GameObject enters a different Tile's bounds, it fires an event.</li> <li>This requires the GameObject to have a Collider component attached.</li> <li>It relies on the \"Trigger Placement\" option being enabled on the Runtime Dungeon Generator, as it uses these trigger volumes to detect transitions.</li> </ul> <p>It has no configurable settings in the Inspector \u2013 its sole purpose is to provide this transition event via code.</p>"},{"location":"advanced-features/character-component/#how-to-use-it","title":"How to Use It","text":"<ol> <li>Add the Component: Attach the <code>DunGen Character</code> component to the GameObject you want to track (e.g., your player character). You can add it via the menu: <code>Add Component &gt; DunGen &gt; Character</code>. Ensure this GameObject also has a <code>Collider</code> component.</li> <li>Enable Tile Triggers: Make sure the <code>Trigger Placement</code> mode is set to either 3D or 2D (depending on your dungeon's perspective) on your <code>Runtime Dungeon</code> component in the scene. Set the <code>Trigger Layer</code> appropriately if needed.</li> <li>Subscribe to the Event: In another script (e.g., your player controller or a UI manager), get a reference to the <code>DunGenCharacter</code> component and subscribe to its <code>OnTileChanged</code> event.</li> </ol> <p>Example Script:</p> PlayerTileTracker.cs<pre><code>using UnityEngine;\nusing DunGen; // Required for DunGenCharacter, Tile\n\npublic class PlayerTileTracker : MonoBehaviour\n{\n    private DungenCharacter characterComponent;\n    private Tile currentTile;\n\n    private void Start()\n    {\n        // Get the DunGenCharacter component attached to the same GameObject\n        characterComponent = GetComponent&lt;DungenCharacter&gt;();\n\n        if (characterComponent == null)\n        {\n            Debug.LogError(\"DungenCharacter component not found on this GameObject!\", this);\n            return;\n        }\n\n        // Subscribe to the tile changed event\n        // The 'OnPlayerTileChanged' method below will be called when the event fires\n        characterComponent.OnTileChanged += OnPlayerTileChanged;\n\n        // Optional: Get the initial tile the character starts in\n        currentTile = characterComponent.CurrentTile;\n\n        if (currentTile != null)\n            Debug.Log($\"Player started in Tile: {currentTile.name}\");\n    }\n\n    private void OnDestroy()\n    {\n        // IMPORTANT: Always unsubscribe from events when the listener is destroyed\n        if (characterComponent != null)\n            characterComponent.OnTileChanged -= OnPlayerTileChanged;\n    }\n\n    // This method signature matches the event delegate\n    // It will be executed whenever the character enters a new tile trigger\n    private void OnPlayerTileChanged(DungenCharacter character, Tile previousTile, Tile newTile)\n    {\n        // Store the new current tile\n        currentTile = newTile;\n\n        // Log the transition\n        string prevTileName = (previousTile != null) ? previousTile.name : \"None\";\n        string newTileName = (newTile != null) ? newTile.name : \"None\";\n        Debug.Log($\"Player moved from Tile '{prevTileName}' to Tile '{newTileName}'\");\n\n        // --- Add your custom logic here ---\n        // UpdateMinimap(newTile);\n        // TriggerRoomSpecificAmbience(newTile);\n        // LoadResourcesForTile(newTile);\n        // UnloadResourcesForTile(previousTile);\n    }\n\n    // Example method you might call from elsewhere\n    public Tile GetCurrentTile()\n    {\n        return currentTile;\n    }\n}\n</code></pre> <p>Event Handler Parameters:</p> <ul> <li><code>DunGenCharacter character</code>: A reference to the <code>DunGenCharacter</code> component that triggered the event (useful if you have multiple tracked characters sharing the same handler).</li> <li><code>Tile previousTile</code>: The <code>Tile</code> the character was in before the transition. Can be <code>null</code> if this is the first tile entered.</li> <li><code>Tile newTile</code>: The <code>Tile</code> the character has just entered. Can be <code>null</code> if the character exits all tile triggers.</li> </ul>"},{"location":"advanced-features/character-component/#use-cases","title":"Use Cases","text":"<ul> <li>Minimap Updates: Highlight the current room/tile on a minimap UI.</li> <li>Environment Effects: Change lighting, ambient sounds, or particle effects based on the current tile the player is in.</li> <li>Resource Streaming: Trigger loading/unloading of assets specific to the entered/exited tiles (if using an asset streaming system).</li> <li>AI Behavior: Notify AI agents about the player's current tile location.</li> <li>Debugging: Log tile transitions to help diagnose generation or gameplay issues.</li> </ul> <p>The <code>DunGen Character</code> component provides a convenient, event-driven way to react to character movement within your generated dungeons without needing to manually manage trigger collisions yourself. Remember the prerequisites: a Collider on the tracked object and \"Trigger Placement\" enabled on the generator.</p>"},{"location":"advanced-features/connection-rules/","title":"Advanced Features: Tile Connection Rules","text":"<p>By default, DunGen tries to connect any two compatible Doorways that line up correctly. However, sometimes you need more control. You might want to prevent certain types of rooms from connecting directly (like two dead-end corridors) or enforce specific connection patterns (like ensuring puzzle rooms only connect to main halls).</p> <p>DunGen provides Tile Connection Rules to achieve this level of control, offering two primary methods:</p> <ol> <li>Tag-Based Rules (Inspector): A simple, visual way to define rules based on tags you assign to your tiles or doorways. Configured in the Dungeon Flow asset.</li> <li>Code-Based Rules (Advanced): Allows you to write custom C# logic for complex connection scenarios, providing fine-grained control based on tile properties, doorway types, or even game state.</li> </ol>"},{"location":"advanced-features/connection-rules/#method-1-tag-based-rules-inspector","title":"Method 1: Tag-Based Rules (Inspector)","text":"<p>This method uses DunGen's built-in tag system. You define custom tags, assign them to your Tile prefabs or Doorways, and then set rules in the Dungeon Flow asset based on pairings of these tags.</p> <p>Step 1: Define Tags</p> <p></p> <ul> <li>First, you need to create the tags you want to use (e.g., \"Room\", \"Corridor\", \"Puzzle\", \"Secret\").</li> <li>Open the DunGen Tag Editor window via the Unity menu: <code>Window &gt; DunGen &gt; Tags</code>.</li> <li>Click \"+ Add Tag\" to create new tags. Give them meaningful names.</li> </ul> <p>DunGen Tags vs. Unity Tags</p> <p>These are DunGen-specific tags and are separate from Unity's built-in GameObject tags.</p> <p>Step 2: Assign Tags to Tiles or Doorways</p> <ul> <li>Select your Tile prefab or Doorway</li> <li>At the bottom of the inspector, find the Tags list.</li> <li>Click the '+' button to add a tag slot, then select the desired tag from the dropdown menu.</li> <li>A single tile or doorway can have multiple tags assigned to it.</li> </ul> <p>Step 3: Configure Rules in Dungeon Flow</p> <ul> <li>Select your <code>Dungeon Flow</code> asset in the Project view.</li> <li>Expand the Connection Rules section at the bottom of the Inspector.</li> <li>Tile vs Doorway: Tags can be applied to doorways or the Tile itself. Choose whichever makes most sense for your use-case (or combine them if needed).</li> <li>Mode: Choose how the rules are applied:<ul> <li><code>Accept</code>: Tiles are only allowed to connect if both tiles have a tag that matches one of the defined Tag Pairs below. If a potential connection doesn't match any pair, it's rejected.</li> <li><code>Reject</code>: Tiles are always allowed to connect unless both tiles have a tag that matches one of the defined Tag Pairs below. If a potential connection matches a pair, it's rejected.</li> </ul> </li> <li>Override Sockets (Doorways only): If checked, DunGen will ignore socket requirements when testing tag pairs. This means you can, for example, say that all doorways that both have a 'Corridor' tag are allowed to connect, even if they have different sockets.</li> <li>Tag Pairs: This list defines the specific tag combinations the <code>Mode</code> setting acts upon.<ul> <li>Click the '+' button to add a new pair.</li> <li>Use the dropdowns to select the two tags for the pair (e.g., Tag A &lt;-&gt; Tag B). The order doesn't matter (<code>Room &lt;-&gt; Corridor</code> is the same as <code>Corridor &lt;-&gt; Room</code>).</li> </ul> </li> </ul> <p></p> <p>Examples:</p> <ul> <li>Scenario: Only allow Rooms to connect to other Rooms or to Corridors. Corridors cannot connect directly to other Corridors.<ul> <li>Mode: <code>Accept</code></li> <li>Tag Pairs:<ul> <li><code>Room</code> &lt;-&gt; <code>Room</code></li> <li><code>Room</code> &lt;-&gt; <code>Corridor</code></li> </ul> </li> </ul> </li> <li>Scenario: Prevent Corridors from connecting directly to other Corridors, but allow all other connections.<ul> <li>Mode: <code>Reject</code></li> <li>Tag Pairs:<ul> <li><code>Corridor</code> &lt;-&gt; <code>Corridor</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"advanced-features/connection-rules/#method-2-code-based-rules-advanced","title":"Method 2: Code-Based Rules (Advanced)","text":"<p>For rules that go beyond simple tag matching (e.g., checking specific doorway properties, tile components, or dynamic conditions), you can implement custom logic in C#.</p> <p>This involves adding a delegate to a static list that DunGen checks during connection evaluation.</p> <p>The Delegate and List:</p> <ul> <li>List: <code>DoorwayPairFinder.CustomConnectionRules</code> - A static list where you add your custom rule methods wrapped in a <code>TileConnectionRule</code> class. Rules are evaluated in order based on the priority of the rules. Higher priority rules are evaluated first.</li> <li> <p>Delegate Signature: Your method must match the <code>TileConnectionRule.TileConnectionDelegate</code> signature, which provides information about the potential connection:</p> <pre><code>// Your method needs to match this signature\nConnectionResult MyCustomRule(ProposedConnection connection);\n</code></pre> </li> </ul> <p>Return Values (<code>ConnectionRuleResult</code>):</p> <p>Your delegate method must return one of the following enum values:</p> <ul> <li><code>ConnectionRuleResult.Allow</code>: Explicitly allows this connection, overriding any subsequent custom rules or default logic.</li> <li><code>ConnectionRuleResult.Deny</code>: Explicitly denies this connection, overriding any subsequent custom rules or default logic.</li> <li><code>ConnectionRuleResult.Passthrough</code>: Your rule makes no decision about this specific connection. DunGen will proceed to check the next rule in the <code>CustomConnectionRules</code> list, or fall back to the default connection logic if no custom rules make a decision.</li> </ul> <p>Adding/Removing the Rule:</p> <ul> <li>Add: Use <code>DoorwayPairFinder.CustomConnectionRules.Add()</code>; typically in <code>Awake()</code> or <code>Start()</code>.</li> <li>Remove: Crucially, you must remove your delegate when it's no longer needed (e.g., in <code>OnDestroy()</code> or <code>OnDisable()</code>) using <code>DoorwayPairFinder.CustomConnectionRules.Remove()</code>. Failure to do so can lead to errors if the delegate points to a destroyed object, or cause rules to persist unexpectedly between generations or scene loads.</li> </ul>"},{"location":"advanced-features/connection-rules/#example-implementation","title":"Example Implementation","text":"<p>Let's say we have a set of large Tiles that we've tagged \"Large\" using DunGen's tagging system. We want to allow connections between two large Tiles only if both doorways use a specific \"Large\" <code>DoorwaySocket</code> asset, otherwise pass the decision to other rules.</p> LargeTileConnectionRule.cs<pre><code>using DunGen;\nusing DunGen.Tags;\nusing UnityEngine;\n\npublic class LargeTileConnectionRule : MonoBehaviour\n{\n    // This is the socket we want to use for large rooms. Set in the inspector\n    public DoorwaySocket LargeSocket = null;\n    // This is the tag we want to use to identify large rooms. Set in the inspector\n    public Tag LargeRoomTag;\n    // The priority of this rule. Higher numbers are evaluated first\n    public int Priority = 0;\n\n    // Keep our rule instance around so we can remove it later\n    private TileConnectionRule rule;\n\n\n    // Register our custom connection rule with the DoorwayPairFinder\n    private void OnEnable()\n    {\n        rule = new TileConnectionRule(CanTilesConnect, Priority);\n        DoorwayPairFinder.CustomConnectionRules.Add(rule);\n    }\n\n    // Unregister our custom connection rule when this object is disabled\n    private void OnDisable()\n    {\n        DoorwayPairFinder.CustomConnectionRules.Remove(rule);\n        rule = null;\n    }\n\n    // Our custom delegate for checking if two tiles can connect\n    private TileConnectionRule.ConnectionResult CanTilesConnect(ProposedConnection connection)\n    {\n        // Check if the two tiles are large. This is using DunGen's tag system, but we could\n        // have also checked the tile names, or looked for a specific component to identify large rooms\n        bool previousTileIsLarge = connection.PreviousTile.Tags.HasTag(LargeRoomTag);\n        bool nextTileIsLarge = connection.NextTile.Tags.HasTag(LargeRoomTag);\n\n        // Are we interested in this connection?\n        if (previousTileIsLarge &amp;&amp; nextTileIsLarge)\n        {\n            // If both sockets are large, allow the connection, otherwise deny\n            if (connection.PreviousDoorway.Socket == LargeSocket &amp;&amp; connection.NextDoorway.Socket == LargeSocket)\n                return TileConnectionRule.ConnectionResult.Allow;\n            else\n                return TileConnectionRule.ConnectionResult.Deny;\n        }\n        // We're not interested in this connection, pass it on to be handled later\n        else\n            return TileConnectionRule.ConnectionResult.Passthrough;\n    }\n}\n</code></pre>"},{"location":"advanced-features/connection-rules/#rule-priority","title":"Rule Priority","text":"<p>It's possible to mix-and-match Tile rules, Doorway rules, and custom rules specified in code. You'll need to be careful when mixing different rule types as it's not obvious at a glance how these rules interact. The order for processing rules is as follows:</p> <ol> <li>Custom code rules are processed first. If any rule returns an <code>Allow</code> or <code>Deny</code> result, no additional rules are processed. If all rules return a <code>Passthrough</code> result, we continue with the rules in the <code>DungeonFlow</code>.</li> <li>Tile rules are processed next. If the tile rules deny the connection, we stop here. If the tile rules allow the connection, we continue to the final set of rules.</li> <li>Finally, Doorway rules are processed.</li> </ol>"},{"location":"advanced-features/connection-rules/#when-to-use-which-method","title":"When to Use Which Method","text":"<ul> <li>Tag-Based: Ideal for simple, static rules based on broad categories of tiles (Room, Corridor, Theme A, Theme B). Easy to set up and visualize in the Inspector.</li> <li>Code-Based: Necessary for complex logic involving specific component checks, doorway socket types, comparisons between tile properties, or conditions based on dynamic game state. Offers maximum flexibility but requires C# scripting.</li> </ul> <p>Using Tile Connection Rules effectively allows for more structured, predictable, and logically sound procedural dungeon layouts.</p>"},{"location":"advanced-features/doors/","title":"Advanced Features: Doors","text":"<p>In the Getting Started section, we saw how to add Connectors and Blockers to Doorway definitions. While Connectors can be simple archways or openings, they are often used to spawn functional Door prefabs. Doors can also be placed automatically via the Lock &amp; Key System.</p> <p>This page focuses on what happens when DunGen places a prefab designated as a door and the crucial <code>Door</code> component that gets added.</p>"},{"location":"advanced-features/doors/#spawning-doors","title":"Spawning Doors","text":"<p>Typically, you designate a door prefab within the Connectors &gt; Random Prefab list of a Doorway component on your Tile prefab.</p> <ul> <li>Priority: Remember the <code>Priority</code> setting within the Connectors list? If two connected doorways both list potential door prefabs, the doorway with the higher priority value gets its prefab chosen. If priorities are equal, one is chosen randomly. Only one door prefab is spawned per doorway connection pair.</li> </ul>"},{"location":"advanced-features/doors/#the-door-component","title":"The <code>Door</code> Component","text":"<p>Whenever DunGen successfully places a prefab that functions as a door (either through the Connectors list or the Lock &amp; Key system), it automatically adds a <code>Door</code> component to the root GameObject of the instantiated door prefab if one does not already exist.</p> <p>This component acts as a vital link between the visual door object and various DunGen systems. It holds information about the connection it represents and, most importantly, its current state.</p>"},{"location":"advanced-features/doors/#key-properties-information","title":"Key Properties &amp; Information","text":"<p>The <code>Door</code> component provides the following useful information (accessible via code):</p> <ul> <li><code>IsOpen</code> (bool): This is the most important property. It represents the logical state of the door (open or closed). You control this property from your custom door scripts (see below). It directly influences visibility for culling and traversability for pathfinding. Default Value: <code>true</code> (open).</li> <li><code>DontCullBehind</code> (bool): If true, the culling system (if any) will not cull tiles behind this door, even when closed.</li> <li><code>DoorwayA</code> (Doorway): A reference to the Doorway component on the first tile of the connection.</li> <li><code>DoorwayB</code> (Doorway): A reference to the Doorway component on the second tile of the connection.</li> <li><code>TileA</code> (Tile): A reference to the Tile component of the first tile.</li> <li><code>TileB</code> (Tile): A reference to the Tile component of the second tile.</li> </ul>"},{"location":"advanced-features/doors/#interaction-with-other-systems","title":"Interaction with Other Systems","text":"<p>The state of the <code>Door.IsOpen</code> property is crucial for integrating doors with other DunGen features:</p> <ol> <li>Culling: DunGen's built-in Adjacent Room Culling systems check the <code>IsOpen</code> state. If <code>Cull Behind Closed Doors</code> is enabled on the culling component, tiles beyond a door where <code>IsOpen</code> is <code>false</code> will not be rendered. Setting <code>IsOpen</code> to <code>true</code> allows the culling system to potentially \"see\" through the doorway.</li> <li>Pathfinding: Supported Pathfinding integrations (like Unity NavMesh Components and A* Pathfinding Project Pro) use the <code>IsOpen</code> state to determine traversability.<ul> <li>For Unity NavMesh, NavMeshLinks generated across the doorway are typically enabled when <code>IsOpen</code> is <code>true</code> and disabled when <code>false</code>.</li> <li>For A* Pathfinding Project Pro, graph connection rules or tag updates often depend on <code>IsOpen</code>, making areas beyond closed doors unwalkable.</li> </ul> </li> </ol>"},{"location":"advanced-features/doors/#creating-custom-doors","title":"Creating Custom Doors","text":"<p>If you create your own custom door prefabs (e.g., with animations for opening and closing), it is essential that your custom door script correctly manages the <code>Door.IsOpen</code> property.</p> <p>Update <code>IsOpen</code> State</p> <p>Your custom script (e.g., <code>MyAnimatedDoor.cs</code>) must get a reference to the <code>Door</code> component on the same GameObject and set the <code>IsOpen</code> property whenever the door's visual state changes.</p> <pre><code>using UnityEngine;\nusing DunGen;\n\n[RequireComponent(typeof(Door))] // Ensure the Door component exists\npublic class MyAnimatedDoor : MonoBehaviour\n{\n    private Door dunGenDoor;\n    private Animator doorAnimator; // Example\n\n    void Awake()\n    {\n        // Get the component added by DunGen\n        dunGenDoor = GetComponent&lt;Door&gt;();\n        doorAnimator = GetComponent&lt;Animator&gt;(); // Example\n    }\n\n    // Call this when your door visually opens\n    public void OpenDoor()\n    {\n        // Play animation, sound, etc.\n        // doorAnimator.SetTrigger(\"Open\"); // Example\n\n        // CRITICAL: Update the DunGen Door component state\n        if (dunGenDoor != null)\n        {\n            dunGenDoor.IsOpen = true;\n        }\n    }\n\n    // Call this when your door visually closes\n    public void CloseDoor()\n    {\n        // Play animation, sound, etc.\n        // doorAnimator.SetTrigger(\"Close\"); // Example\n\n        // CRITICAL: Update the DunGen Door component state\n        if (dunGenDoor != null)\n        {\n            dunGenDoor.IsOpen = false;\n        }\n    }\n\n    // Example: Simple interaction\n    void OnTriggerEnter(Collider other)\n    {\n        if (other.CompareTag(\"Player\")) // Example tag\n        {\n            OpenDoor();\n        }\n    }\n}\n</code></pre> <p>By correctly updating <code>Door.IsOpen</code>, you ensure that DunGen's culling and pathfinding systems accurately reflect the current state of your custom doors, leading to correct visibility and navigation behaviour in your generated dungeons.</p>"},{"location":"advanced-features/injecting-tiles/","title":"Advanced Features: Injecting Special Tiles","text":"<p>Sometimes, the standard random selection of tiles based on Tile Sets and Archetypes isn't enough. You might need to guarantee that a specific type of tile (like a boss room, a unique quest location, or a special challenge room) appears in the dungeon, perhaps only once, or within a specific area.</p> <p>This is where Tile Injection comes in. It allows you to \"inject\" tiles from a specified Tile Set into the dungeon generation process, overriding the normal selection based on a set of rules you define.</p> <p>There are two main ways to implement Tile Injection:</p> <ol> <li>Using the Inspector (Simple Rules): Configure injection rules directly on your Dungeon Flow asset for common scenarios.</li> <li>Using Code (Complex Rules): Write custom logic to add injection rules dynamically for maximum flexibility.</li> </ol>"},{"location":"advanced-features/injecting-tiles/#method-1-tile-injection-via-inspector","title":"Method 1: Tile Injection via Inspector","text":"<p>For straightforward injection rules based on location within the dungeon, you can configure them directly in the Special Tile Injection section of your <code>Dungeon Flow</code> asset inspector.</p> <ol> <li>Select your <code>Dungeon Flow</code> asset in the Project view.</li> <li>Find the Special Tile Injection foldout in the Inspector.</li> <li>Click \"Add New Rule\" to create an injection entry.</li> </ol> <p>Each rule defines conditions under which a tile from a specified Tile Set should be injected:</p> <ul> <li>Tile Set (e.g., \"Special Tiles\"): Drag the Tile Set asset containing the tile(s) you want to inject here. When this rule triggers, DunGen will randomly select one tile from this Tile Set to place.</li> <li>Is Required?<ul> <li>Checked: This tile must be successfully placed according to the rules. If DunGen fails to generate a valid dungeon layout that includes this required injection (e.g., due to restrictive placement rules or collisions), it will retry the entire dungeon generation until it succeeds.</li> <li>Unchecked: DunGen will attempt to place this tile according to the rules, but if it fails (e.g., no suitable location found within the depth range), generation will continue without it.</li> </ul> <p>Performance Impact</p> <p>Using <code>Is Required?</code> can increase generation time, especially if the placement rules (<code>Path Depth</code>, <code>Branch Depth</code>) are very narrow or if collisions are likely. Use it only when placement is absolutely essential.</p> </li> <li>Can appear on Main Path? If checked, this rule allows the tile to be injected somewhere along the main path (Start to Goal).</li> <li>Can appear on Branch Path? If checked, this rule allows the tile to be injected somewhere along an optional branch path.</li> <li>Locked: If checked, the entrance to this tile will be locked.</li> <li>Lock Type: Which lock from the <code>KeyManager</code> to use.</li> <li>Path Depth: Defines the normalized range along the main path where this injection is allowed.<ul> <li><code>0</code> represents the Start tile location.</li> <li><code>1</code> represents the Goal tile location.</li> <li>A range of <code>0.4</code> to <code>0.6</code> means the tile can only be injected near the middle of the main path.</li> </ul> </li> <li>Branch Depth: (Only used if <code>Can appear on Branch Path</code> is checked) Defines the normalized range along a branch path where this injection is allowed.<ul> <li><code>0</code> represents the first tile of the branch (connected to the main path).</li> <li><code>1</code> represents the final tile (dead end) of the branch.</li> <li>A range of <code>0.9</code> to <code>1.0</code> means the tile can only be injected near the end of a branch.</li> </ul> </li> </ul> <p>You can add multiple rules to inject different types of special tiles under various conditions.</p>"},{"location":"advanced-features/injecting-tiles/#method-2-tile-injection-through-code","title":"Method 2: Tile Injection Through Code","text":"<p>For more advanced scenarios where injection rules depend on dynamic game state, complex logic, or need more fine-grained control, you can inject tiles via code.</p> <p>This involves creating a method that matches the <code>TileInjectionDelegate</code> signature and adding it to the <code>TileInjectionMethods</code> list on the <code>DungeonGenerator</code> instance.</p> <p>The Delegate Signature:</p> <pre><code>// Your method needs to match this pattern\nvoid MyInjectionLogic(DunGen.RandomStream randomStream, ref List&lt;InjectedTile&gt; tilesToInject);\n</code></pre> <ul> <li><code>randomStream</code>: The <code>DunGen.RandomStream</code> instance used for the current dungeon generation. Use this if your injection logic needs randomness consistent with the dungeon seed.</li> <li><code>tilesToInject</code>: A list of <code>InjectedTile</code> objects. Your method must add new <code>InjectedTile</code> instances to this list. DunGen will then process this list during generation.</li> </ul>"},{"location":"advanced-features/injecting-tiles/#the-injectedtile-class","title":"The InjectedTile Class:","text":"<p>You create instances of <code>InjectedTile</code> to represent the tiles you want to inject. The <code>InjectedTile</code> class has the following properties:</p> <ul> <li>TileSet (<code>TileSet</code>): The TileSet to inject.</li> <li>NormalizedPathDepth (<code>float</code>): Normalized (0-1) depth along the main path that this tile should be spawned (0 = Start, 1 = Goal).</li> <li>NormalizedBranchDepth (<code>float</code>): (Only valid if spawned on a branch) Normalized (0-1) depth along the branch that this tile should be spawned (0 = Branch Entrance, 1 = Branch Cap)</li> <li>IsOnMainPath (<code>bool</code>): Should this tile be spawned on the main path? If false, it will be spawned on a branch.</li> <li>IsRequired (<code>bool</code>): If true, DunGen will regenerate the dungeon if it fails to spawn this injected tile.</li> <li>IsLocked (<code>bool</code>): Should the entrance to this tile be locked using the Lock &amp; Key System?</li> <li>LockID (<code>int</code>): (Only used if <code>IsLocked</code> is true) The ID of the lock to use. This is the index of the lock found in the <code>KeyManager</code>.</li> </ul> Example Implementation <p>In this example, we will inject a random tile from the <code>TileSet</code> assigned to <code>MySpecialTileSet</code> onto the end of the first branch encountered after the halfway point of the main path.</p> CustomTileInjector.cs<pre><code>using UnityEngine;\nusing DunGen;\nusing System.Collections.Generic;\n\npublic class CustomTileInjector : MonoBehaviour\n{\n    // Assign your Runtime Dungeon Generator here\n    public RuntimeDungeon RuntimeDungeon;\n\n    // Assign the TileSet containing your special tile(s)\n    public TileSet MySpecialTileSet;\n\n\n    private void Start()\n    {\n        if (RuntimeDungeon != null &amp;&amp; RuntimeDungeon.Generator != null)\n            RuntimeDungeon.Generator.TileInjectionMethods += InjectMySpecialTile;\n        else\n            Debug.LogError(\"RuntimeDungeon or its Generator is not assigned\");\n    }\n\n    // This method matches the TileInjectionDelegate\n    private void InjectMySpecialTile(RandomStream randomStream, ref List&lt;InjectedTile&gt; tilesToInject)\n    {\n        // Define the injection parameters\n        bool tryOnMainPath = false;  // Let's target a branch path in this example\n        float targetPathDepth = 0.5f; // We want this to spawn at the halfway point of the main path\n        float targetBranchDepth = 1.0f; // Target the very end of the branch\n        bool mustBePlaced = false; // It's okay if this tile isn't placed\n\n        var tileToInject = new InjectedTile(MySpecialTileSet, tryOnMainPath, targetPathDepth, targetBranchDepth, mustBePlaced);\n\n        // Add it to the list DunGen will process\n        tilesToInject.Add(tileToInject);\n    }\n\n    // Unsubscribe when the object is destroyed\n    private void OnDestroy()\n    {\n        if (RuntimeDungeon != null &amp;&amp; RuntimeDungeon.Generator != null)\n            RuntimeDungeon.Generator.TileInjectionMethods -= InjectMySpecialTile;\n    }\n}\n</code></pre>"},{"location":"advanced-features/injecting-tiles/#attaching-the-delegate","title":"Attaching the Delegate:","text":"<p>You typically add your custom injection method to the <code>TileInjectionMethods</code> list before generation begins, often in a <code>Start()</code> or <code>Awake()</code> method after getting a reference to the <code>DungeonGenerator</code>. Remember to unsubscribe (-=) in <code>OnDestroy()</code> or <code>OnDisable()</code> to prevent issues if the generator object persists longer than your injector script.</p>"},{"location":"advanced-features/injecting-tiles/#when-to-use-which-method","title":"When to Use Which Method","text":"<ul> <li> <p>Inspector: Best for simple, static rules based purely on placement depth (main/branch path ranges) and whether the tile is required. Easy to set up and manage without code.</p> </li> <li> <p>Code: Necessary when injection logic is complex, depends on external factors (game state, player progress), requires dynamic calculation of placement, or needs to inject multiple different tiles based on intricate conditions. Offers ultimate flexibility but requires scripting knowledge.</p> </li> </ul> <p>Tile Injection is a powerful tool for adding specific, authored moments or structures within your otherwise randomized dungeons.</p>"},{"location":"advanced-features/lock-key-system/","title":"Advanced Features: Lock &amp; Key System","text":"<p>DunGen includes a robust system for procedurally placing locked doors and their corresponding keys within your dungeon layouts. This allows you to create progression gates, control access to specific areas (like boss rooms), and add another layer of dynamic gameplay.</p> <p>Implementing the Lock &amp; Key system involves configuration across several assets and requires some C# scripting to integrate the key pickup and door unlocking logic into your actual game mechanics.</p> <p>The Core Components:</p> <ol> <li>Key Manager Asset: Defines the different types of keys available in your dungeon.</li> <li>Tile Set Asset: Specifies which prefabs to use for locked doors.</li> <li>Dungeon Flow Asset: Determines where locks and keys should be placed within the dungeon structure.</li> <li>Runtime Interfaces (<code>IKeySpawner</code>, <code>IKeyLock</code>): C# interfaces you implement to tell DunGen how to spawn key objects and notify your prefabs when they are assigned a specific key type.</li> </ol>"},{"location":"advanced-features/lock-key-system/#1-creating-the-key-manager","title":"1. Creating the Key Manager","text":"<p>First, you need to define the types of keys your dungeon can use.</p> <ol> <li>Create a Key Manager asset: Right-click in Project view &gt; <code>Create &gt; DunGen &gt; Key Manager</code>.</li> <li>Select the asset. In the Inspector, click \"Add New Key\" for each distinct key type you need (e.g., Red Key, Blue Key, Boss Key).</li> <li>Configure each Key Type:<ul> <li>Name: A human-readable name (e.g., \"Red Skeleton Key\"). Used for identification, potentially in UI.</li> <li>Prefab: (Optional) A prefab representing the key visually in the scene (e.g., a collectible key model). DunGen will tell your code which prefab to potentially spawn via the <code>IKeySpawner</code> interface.</li> <li>Colour: (Optional) A color used for visual debugging in the editor and potentially for color-coding locks and keys in your game via the <code>IKeyLock</code> interface.</li> </ul> <p>Note</p> <p>These properties (Prefab, Colour) are conveniences. Whether you use them depends entirely on how you implement the runtime interfaces later.</p> </li> <li>Link to Dungeon Flow: You must assign this Key Manager asset to the <code>Key Manager</code> field in your Dungeon Flow asset so DunGen knows which keys are available for that flow.</li> </ol>"},{"location":"advanced-features/lock-key-system/#2-assigning-a-locked-door-prefab","title":"2. Assigning a Locked Door Prefab","text":"<p>Next, tell DunGen which prefab(s) represent a locked door. This is done per Tile Set.</p> <ol> <li>Select a Tile Set asset that contains tiles where locked doors might appear.</li> <li>In the Inspector, find the \"Locked Door Prefabs\" section.</li> <li>Click \"Add\" to create an entry for a specific Doorway Socket. Choose the relevant socket from the dropdown (e.g., \"Default\").<ul> <li>This means when a lock is placed on a connection using this socket type, and involving a tile from this Tile Set, DunGen will look here for the prefab to use.</li> </ul> </li> <li>Within that socket entry, click \"Add New Prefab\" and drag your locked door prefab(s) into the slot(s).</li> <li>Configure Weights if you add multiple locked door prefabs for the same socket type. The weights determine the likelihood of each prefab being chosen when that type of locked door is needed.</li> </ol>"},{"location":"advanced-features/lock-key-system/#3-placing-keys-and-locks-dungeon-flow","title":"3. Placing Keys and Locks (Dungeon Flow)","text":"<p>Now, define where in the dungeon structure keys and locks should appear. This is configured in the Dungeon Flow editor.</p> <ol> <li>Select your Dungeon Flow asset and click \"Open Flow Editor\".</li> <li>Select a Node or a Line Segment in the graph.</li> <li>In the Inspector, you'll find <code>Keys</code> and <code>Locks</code> lists.</li> </ol>"},{"location":"advanced-features/lock-key-system/#assigning-keyslocks","title":"Assigning Keys/Locks:","text":"<ul> <li>Click \"Add\" under the <code>Keys</code> or <code>Locks</code> list.</li> <li>Select the desired Key Type (defined in your Key Manager) from the dropdown.</li> </ul>"},{"location":"advanced-features/lock-key-system/#placement-differences","title":"Placement Differences:","text":"<ul> <li>Nodes: Keys/Locks assigned here will be placed specifically within the single tile generated by that node.</li> <li>Line Segments: Keys/Locks assigned here will be placed randomly somewhere along the sequence of tiles generated by that line segment.</li> </ul>"},{"location":"advanced-features/lock-key-system/#node-specific-setting-lock-placement","title":"Node-Specific Setting: <code>Lock Placement</code>","text":"<ul> <li>When assigning a Lock to a Node, you get an extra <code>Lock Placement</code> option:<ul> <li><code>Entrance</code>: The locked door will only be placed on the doorway the player enters the node's tile through. Essential for boss rooms or requiring a key found earlier to enter a specific tile.</li> <li><code>Exit</code>: The locked door will only be placed on the doorway used to exit the node's tile.</li> <li><code>Any</code>: The locked door can be placed on any doorway connected to the node's tile.</li> </ul> </li> </ul>"},{"location":"advanced-features/lock-key-system/#line-segment-setting-lock-count","title":"Line Segment Setting: Lock <code>Count</code>","text":"<ul> <li>When assigning a Lock to a Line Segment, you can specify a <code>Count</code> (Min/Max) for how many instances of that lock type should appear within that segment.</li> </ul> <p>Solvability Guarantee</p> <p>DunGen's logic ensures dungeons are always completable regarding locks and keys:</p> <ol> <li>It places Locks first based on your Flow configuration.</li> <li>It then determines where the corresponding Keys must be placed.</li> <li>It guarantees that keys are placed in locations accessible before their corresponding locks are encountered along the main path. It uses the potential key locations you assigned in the Flow Editor to find valid spots.</li> </ol>"},{"location":"advanced-features/lock-key-system/#4-tying-it-into-our-game-runtime-integration","title":"4. Tying it into our Game (Runtime Integration)","text":"<p>DunGen handles the placement logic, but it needs your C# code to handle the game-specific actions of spawning key objects and reacting to lock/key assignments. This is done by implementing two interfaces:</p>"},{"location":"advanced-features/lock-key-system/#ikeyspawner-interface","title":"<code>IKeySpawner</code> Interface","text":"<ul> <li>Purpose: Implement this interface on a component to tell DunGen how and where a key object should actually appear in the game.</li> <li>Method: <code>void SpawnKey(KeySpawnParameters keySpawnParameters);</code></li> <li>Workflow:<ol> <li>When DunGen decides a specific <code>Key</code> needs to be placed at a location defined in the Dungeon Flow (Node or Line Segment).</li> <li>It searches for GameObjects at valid positions within the target Tile(s).</li> <li>It finds components on those GameObjects that implement <code>IKeySpawner</code>.</li> <li>It randomly selects one of these components.</li> <li>It calls the <code>SpawnKey</code> method on the selected component, passing information about the specific <code>Key</code> type.</li> </ol> </li> <li> <p>Implementation Examples:</p> <ul> <li>Spawn Prefab: Your <code>SpawnKey</code> method could instantiate the <code>key.Prefab</code> at the component's position (like the demo scene's <code>KeySpawnPoint</code> script).</li> <li>Add to Inventory: Your <code>SpawnKey</code> method on an enemy's script could add the <code>key</code> to that enemy's drop loot table.</li> <li>Place in Chest: Your <code>SpawnKey</code> method on a chest script could add the <code>key</code> to the chest's contents.</li> </ul> KeySpawnPoint.cs<pre><code>using UnityEngine;\nusing DunGen;\nusing DunGen.LockAndKey;\n\npublic class KeySpawnPoint : MonoBehaviour, IKeySpawner\n{\n    // Check if the key has already been spawned\n    public bool HasSpawnedKey =&gt; spawnedKey != null;\n\n    private GameObject spawnedKey;\n\n\n    public bool CanSpawnKey(KeyManager keyManager, Key key)\n    {\n        // We can't spawn a key if one has already been spawned\n        if (HasSpawnedKey)\n            return false;\n\n        // We can't spawn a key if it has no prefab\n        return key.Prefab != null;\n    }\n\n    public void SpawnKey(KeySpawnParameters keySpawnParameters)\n    {\n        var key = keySpawnParameters.Key;\n\n        if (keySpawnParameters.Key.Prefab == null)\n        {\n            Debug.LogWarning($\"Key '{key.Name}' needs to be spawned here, but has no Prefab assigned in the Key Manager.\", this);\n            return;\n        }\n\n        // Instantiate the key prefab defined in the Key Manager\n        spawnedKey = Instantiate(key.Prefab, transform.position, transform.rotation);\n\n        // Notify the DunGen about any IKeyLock components that were created\n        var keyLockComponents = spawnedKey.GetComponentsInChildren&lt;IKeyLock&gt;();\n        keySpawnParameters.OutputSpawnedKeys.AddRange(keyLockComponents);\n    }\n}\n</code></pre> </li> </ul> <p>Props &amp; Keys Timing</p> <p>Props (Local, Random, Global) are processed before the Lock &amp; Key system runs. This means if you have a chest placed as a random prop, DunGen can correctly identify it later as a potential spawn location for a key if the chest's script implements <code>IKeySpawner</code>.</p>"},{"location":"advanced-features/lock-key-system/#ikeylock-interface","title":"<code>IKeyLock</code> Interface","text":"<ul> <li>Purpose: Implement this interface on components within your Locked Door prefabs and your Key prefabs to be notified which specific Key type has been assigned to them.</li> <li>Method: <code>void OnKeyAssigned(Key key, KeyManager manager);</code></li> <li>Workflow:<ol> <li>When DunGen places a locked door prefab, it calls <code>OnKeyAssigned</code> on all components implementing <code>IKeyLock</code> within that prefab's hierarchy, passing the assigned <code>Key</code>.</li> <li>When DunGen tells your <code>IKeySpawner</code> to spawn a key and you (optionally) return a list of spawned <code>IKeyLock</code> back to DunGen. <code>OnKeyAssigned</code> will be called automatically on all of these components.</li> </ol> </li> <li> <p>Implementation Examples:</p> <ul> <li>Visual Feedback: Change the color of a mesh renderer on the lock/key based on <code>key.Colour</code> (like the demo scene's <code>KeyColour</code> script).</li> <li>Store Key Info: Store the required <code>Key</code> object on the locked door script so you know what key the player needs when they interact with it.</li> <li>Initialize Key Object: Set up properties on the collectible key script based on the assigned <code>Key</code> type.</li> </ul> KeyColour.cs<pre><code>using UnityEngine;\nusing DunGen;\n\npublic class KeyColour : MonoBehaviour, IKeyLock\n{\n    // Assign in Inspector\n    public Renderer TargetRenderer;\n\n    // Used to change material properties without leaking material instances into the scene\n    private MaterialPropertyBlock propertyBlock;\n\n\n    public void OnKeyAssigned(Key key, KeyManager manager)\n    {\n        if (TargetRenderer != null)\n        {\n            if(propertyBlock == null)\n                propertyBlock = new MaterialPropertyBlock();\n\n            // Use the color defined in the Key Manager\n            propertyBlock.SetColor(\"_Color\", key.Colour);\n            TargetRenderer.SetPropertyBlock(propertyBlock);\n        }\n    }\n}\n</code></pre> </li> </ul> <p>By combining asset configuration with these runtime interfaces, you can create complex and solvable lock and key puzzles within your procedurally generated DunGen levels. Remember that the actual player interaction logic (detecting key pickup, checking inventory, triggering door unlocks) needs to be implemented in your own game systems.</p>"},{"location":"advanced-features/multiple-floors/","title":"Advanced Features: Multiple Floors","text":"<p>Adding verticality to your dungeons can create more interesting exploration, distinct floor levels, and a better sense of scale or progression. DunGen supports multiple floors not through a specific feature, but by leveraging the core Tile and Doorway system.</p>"},{"location":"advanced-features/multiple-floors/#how-it-works-vertical-doorway-placement","title":"How it Works: Vertical Doorway Placement","text":"<p>The key to achieving multi-floor layouts is simple: create Tile prefabs where Doorway components are placed at different Y-coordinates (heights).</p> <p>DunGen's generation process works by aligning the world-space position and orientation of doorways when connecting tiles. If two connected doorways have different Y-positions in their respective Tile prefabs, the newly placed Tile will naturally be positioned higher or lower than the previous one, creating a change in floor level.</p> <p>A common example is a Tile representing a staircase:</p> <p></p> <p>A <code>Tile</code> with multiple <code>Doorways</code> at different heights</p> <p>When DunGen uses such a Tile, it seamlessly integrates vertical movement into the layout. If you simply include these \"transition\" Tiles in your regular Tile Sets, floor changes will occur organically based on random selection.</p> <p>However, if you need more precise control over when and how floor transitions happen, you can use the following techniques.</p>"},{"location":"advanced-features/multiple-floors/#controlling-floor-transitions","title":"Controlling Floor Transitions","text":"<p>Here are several ways to manage verticality in your dungeon generation:</p>"},{"location":"advanced-features/multiple-floors/#forcing-transition-direction-via-doorway-constraints","title":"Forcing Transition Direction (via Doorway Constraints)","text":"<p>You can dictate the direction of travel through a transition tile. If you want a specific staircase Tile to only ever lead upwards from the point of entry:</p> <ol> <li>Select the transition Tile prefab.</li> <li>Inspect its Tile Component.</li> <li>In the <code>Entrances</code> list, assign only the lower Doorway(s).</li> </ol> <p>Now, DunGen can only enter this Tile via the bottom doorways, forcing the connection path to proceed upwards to exit through the higher doorways. Conversely, assigning only the upper doorways to <code>Entrances</code> forces downward transitions.</p>"},{"location":"advanced-features/multiple-floors/#dedicated-transition-points-via-flow-nodes","title":"Dedicated Transition Points (via Flow Nodes)","text":"<p>To ensure a floor transition happens at a specific point in the dungeon's progression:</p> <ol> <li>Create a dedicated Tile Set containing only your floor transition Tiles (like staircases, ramps, elevators).</li> <li>In the Dungeon Flow Editor, add a new Node along the main path where you want the transition to occur.</li> <li>Assign your dedicated transition Tile Set to this specific Node. DunGen will be forced to pick a transition Tile at that exact point in the layout.</li> </ol>"},{"location":"advanced-features/multiple-floors/#generating-distinct-floors-sequentially","title":"Generating Distinct Floors Sequentially","text":"<p>To create completely separate floors generated one after another:</p> <ol> <li>Design your first floor's layout in the Dungeon Flow Editor.</li> <li>Assign a Tile Set containing only upward transition Tiles (e.g., stairs leading up) to the <code>Goal</code> Node of this first floor's flow graph.</li> <li>Generate the first floor dungeon. It will end with a transition Tile leading to an unused Doorway at the upper level.</li> <li>Use the Generating Attached Dungeons feature to generate a second dungeon instance, instructing it to attach specifically to that unused upper Doorway. This second dungeon instance will represent the next floor. Repeat as needed for more floors.</li> </ol> <p>Effective use of multiple floors adds depth and complexity to your generated levels. By designing appropriate transition Tiles and using DunGen's flow control features, you can create compelling multi-level environments.</p>"},{"location":"advanced-features/post-processing/","title":"Advanced Features: Custom Post-Processing Steps","text":"<p>DunGen's generation process involves several stages: creating the main path, adding branches, placing props, handling the lock &amp; key system, etc. Sometimes, you need to inject your own custom logic during this process, specifically after the main dungeon layout (<code>Dungeon</code> data structure) exists but before generation is fully marked as complete.</p> <p>This is useful for:</p> <ul> <li>Integrating third-party systems (like pathfinding baking or custom culling setups) that need the final level geometry.</li> <li>Running complex analysis or modification routines on the generated <code>Dungeon</code> data.</li> <li>Implementing custom prop placement logic that depends on the overall dungeon structure.</li> <li>Performing tasks that need to happen after DunGen's built-in post-processing (like lock/key placement) but before the final <code>GenerationStatus.Complete</code> event fires.</li> </ul> <p>DunGen offers two ways to add your custom post-processing logic:</p> <ol> <li>Registering Steps via Code: Use the <code>RegisterPostProcessStep</code> method on the <code>DungeonGenerator</code> for fine-grained control.</li> <li>Creating Custom Adapters: Derive a component from <code>BaseAdapter</code> for a more component-based approach, often used for integrations.</li> </ol>"},{"location":"advanced-features/post-processing/#method-1-registering-steps-via-code-registerpostprocessstep","title":"Method 1: Registering Steps via Code (<code>RegisterPostProcessStep</code>)","text":"<p>This method allows you to dynamically register a C# method to be called during the post-processing phase.</p> <p>How it Works:</p> <ol> <li>Get a reference to your <code>DungeonGenerator</code> instance.</li> <li>Call the <code>generator.RegisterPostProcessStep()</code> method, providing your callback method and configuration options.</li> <li>DunGen will execute your callback method at the appropriate time during its post-processing phase.</li> </ol> <p>The Method Signature:</p> <pre><code>void RegisterPostProcessStep(Action&lt;DungeonGenerator&gt; postProcessCallback, int priority, PostProcessPhase phase);\n</code></pre> <ul> <li><code>Action&lt;DungeonGenerator&gt; postProcessCallback</code>: This is your custom method (or lambda expression) that will be executed. It receives the <code>DungeonGenerator</code> instance as an argument, allowing you to access the generated dungeon data via <code>generator.CurrentDungeon</code>.</li> <li><code>int priority</code>: Determines the execution order within a specific phase. Higher priority numbers execute first. Steps with the same priority have an undefined execution order relative to each other. DunGen's built-in steps (like lock/key placement) also have priorities.</li> <li><code>PostProcessPhase phase</code>: An enum specifying when your step should run relative to DunGen's internal post-processing:<ul> <li><code>PostProcessPhase.BeforeBuiltIn</code>: Your step runs before DunGen handles its standard post-processing (Locks, Keys, Props, etc).</li> <li><code>PostProcessPhase.AfterBuiltIn</code>: Your step runs after DunGen handles its standard post-processing.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>public class MyCustomPostProcessor : MonoBehaviour\n{\n    // Assign your Runtime Dungeon component in the inspector\n    public RuntimeDungeon RuntimeDungeon;\n\n    private void Start()\n    {\n        if (RuntimeDungeon == null)\n            return;\n\n        // Register our custom method to run AFTER DunGen's built-in steps, with priority 0\n        RuntimeDungeon.Generator.RegisterPostProcessStep(MyCustomPostProcessLogic, 0, PostProcessPhase.AfterBuiltIn);\n    }\n\n    private void OnDestroy()\n    {\n        if (RuntimeDungeon == null)\n            return;\n\n        // Unregister our custom method\n        RuntimeDungeon.Generator.UnregisterPostProcessStep(MyCustomPostProcessLogic);\n    }\n\n    // This is the method that gets called by DunGen\n    private void MyCustomPostProcessLogic(DungeonGenerator generator)\n    {\n        Debug.Log(\"Running custom post-process step!\");\n\n        // Access the generated dungeon data\n        Dungeon dungeon = generator.CurrentDungeon;\n\n        // Perform your custom logic here\n        Debug.Log($\"Dungeon has {dungeon.AllTiles.Count} tiles.\");\n    }\n}\n</code></pre> <p>Use Cases: Ideal for one-off post-processing tasks defined in specific scripts, or when you need precise control over execution order relative to DunGen's built-in steps.</p>"},{"location":"advanced-features/post-processing/#method-2-creating-custom-adapters-baseadapter","title":"Method 2: Creating Custom Adapters (<code>BaseAdapter</code>)","text":"<p>This approach is more component-oriented and is the standard way DunGen integrates systems like Pathfinding and Culling. You create a new script that inherits from <code>DunGen.Adapters.BaseAdapter</code>.</p> <p>How it Works:</p> <ol> <li>Create a new C# script.</li> <li>Make it inherit from <code>DunGen.Adapters.BaseAdapter</code>.</li> <li>Override the abstract <code>Run(DungeonGenerator generator)</code> method. This is where your custom logic goes.</li> <li>Attach this new component script to the same GameObject that has the <code>RuntimeDungeon</code> component.</li> <li>DunGen will automatically find all <code>BaseAdapter</code> components on that GameObject and execute their <code>Run</code> methods during the post-processing phase.</li> </ol> <p>Adapter Properties:</p> <ul> <li><code>Priority</code> (Inspector Field): Inherited from <code>BaseAdapter</code>. This integer value controls the execution order of all post-processing steps within the same phase. Higher priority adapters run first.</li> </ul> <p>Execution Phase</p> <p>Adapters derived from <code>BaseAdapter</code> run after DunGen's built-in post-processing steps, similar to <code>PostProcessPhase.AfterBuiltIn</code>.</p> <p>Example:</p> <pre><code>using UnityEngine;\nusing DunGen;\nusing DunGen.Adapters;\n\n// Attach this component to the same GameObject as RuntimeDungeon\npublic class MyCustomAdapter : BaseAdapter\n{\n    protected override void Run(DungeonGenerator generator)\n    {\n        Debug.Log($\"Running MyCustomAdapter (Priority: {Priority})\");\n\n        Dungeon dungeon = generator.CurrentDungeon;\n        if (dungeon == null)\n        {\n            Debug.LogError(\"Dungeon data is null in custom adapter!\", this);\n            return;\n        }\n\n        // --- Add custom logic here ---\n        Debug.Log($\"Adapter processing dungeon with {dungeon.AllTiles.Count} tiles.\");\n        // Example: Find all objects with a specific tag and activate them\n        // foreach(var tile in dungeon.AllTiles) { ... }\n    }\n}\n</code></pre> <p>Use Cases: Excellent for creating reusable integration components (like the built-in pathfinding/culling adapters), especially when the logic might need configuration via Inspector fields on the component itself. Easier to manage as self-contained units.</p>"},{"location":"advanced-features/post-processing/#choosing-the-right-method","title":"Choosing the Right Method","text":"<ul> <li><code>RegisterPostProcessStep</code>:<ul> <li>Use when you need very fine control over execution order relative to DunGen's internal steps (<code>BeforeBuiltIn</code> vs. <code>AfterBuiltIn</code>).</li> <li>Use when the logic is part of a script that isn't naturally attached to the <code>RuntimeDungeon</code> GameObject.</li> <li>Use when you need to dynamically add/remove steps based on runtime conditions.</li> </ul> </li> <li><code>BaseAdapter</code>:<ul> <li>Use for creating self-contained, reusable integration components (preferred for integrations like pathfinding, culling, etc.).</li> <li>Use when you want to configure the step via the Inspector (add public fields to your adapter).</li> <li>Generally simpler setup if you just need logic to run after the main generation and built-in steps. Ordering is primarily relative to other adapters.</li> </ul> </li> </ul> <p>Custom post-processing provides a vital hook for tailoring the generated dungeon and integrating it fully with your game systems.</p>"},{"location":"advanced-features/props-variety/","title":"Advanced Features: Props for Variety","text":"<p>Creating many unique Tile prefabs can be time-consuming. DunGen offers several \"Prop\" components that allow you to add significant visual variety and randomness to your existing Tiles without needing to create entirely new room geometry. These components let you dynamically include, exclude, or choose between different GameObjects or prefabs within your Tiles during dungeon generation.</p> <p>There are three main types of prop components:</p> <ol> <li>Local Prop Set: Manages a collection of existing GameObjects within a Tile, keeping some and discarding others.</li> <li>Random Prefab: Spawns one chosen prefab from a list at a specific location within a Tile.</li> <li>Global Prop: Ensures only a specific total number of a certain type of prop exists across the entire generated dungeon.</li> </ol> <p>Recursive Props</p> <p>Props are processed recursively, allowing you to have props that control other props. For example, you might have a \"decoration\" Random Prefab that spawns a random decorative object that could go on a table (e.g., a book, candle, or ornament). You could then have this prop be controlled by a Local Prop Set, that decides which of the \"decoration\" objects to keep.</p> <p>Let's explore each one.</p>"},{"location":"advanced-features/props-variety/#local-prop-set","title":"Local Prop Set","text":"<ul> <li>Purpose: To selectively keep a subset of GameObjects that are already placed within your Tile prefab. Ideal for over-decorating a room in the editor and then having DunGen randomly remove some items for variety.</li> <li>Setup: Add the <code>Local Prop Set</code> component (<code>Add Component &gt; DunGen &gt; Random Props &gt; Local Prop Set</code>) to a GameObject within your Tile prefab. The GameObjects you want this component to manage should be children of the GameObject holding the <code>Local Prop Set</code> component.</li> </ul>"},{"location":"advanced-features/props-variety/#inspector-settings","title":"Inspector Settings:","text":"<ul> <li>Count Mode: Determines how the number of props to keep is decided:<ul> <li><code>Random</code>: A random number between the <code>Min</code> and <code>Max</code> values of the <code>Count</code> range below will be chosen.</li> <li><code>Depth Based</code>: Uses the <code>Depth Scale</code> curve (see Prop Weights below). The X-axis (0-1) represents the normalized path depth, and the Y-axis (0-1) maps to the number of props kept (0 = Min Count, 1 = Max Count).</li> <li><code>Depth Multiply</code>: A random number between <code>Min</code> and <code>Max</code> is chosen (like <code>Random</code> mode), but this number is then multiplied by the value from the <code>Depth Scale</code> curve (Y-axis 0-1) at the current path depth.</li> </ul> </li> <li>Count (Min/Max): Defines the minimum and maximum number of child GameObjects that this component should keep active.</li> <li>Prop Weights: This list holds references to the child GameObjects that the Local Prop Set manages.<ul> <li>Adding Props: Drag the child GameObjects from the Hierarchy into this list, or click \"Add Selected Props\" after selecting them in the Hierarchy.</li> <li>Weight per Prop: Each prop entry has its own weight settings (<code>Main Path</code>, <code>Branch Path</code>, <code>Depth Scale</code>). When the component needs to decide which props to keep (if it needs to discard some to meet the count), props with a higher effective weight are more likely to be chosen. Refer to the Weighting page for details.</li> </ul> </li> </ul> <p>Outcome: When the Tile containing this component is placed, the <code>Local Prop Set</code> calculates how many of its child props to keep based on the <code>Count Mode</code> and <code>Count</code> range. It then selects which props to keep based on their weights and disables (discards) the rest.</p>"},{"location":"advanced-features/props-variety/#random-prefab","title":"Random Prefab","text":"<ul> <li>Purpose: To spawn a single prefab instance chosen randomly from a list you provide. Ideal for placing randomized decorations, containers, or interactive objects at specific points.</li> <li>Setup: Add the <code>Random Prefab</code> component (<code>Add Component &gt; DunGen &gt; Random Props &gt; Random Prefab</code>) to an empty GameObject within your Tile prefab. This empty GameObject acts as a marker for the spawn location and rotation.</li> </ul>"},{"location":"advanced-features/props-variety/#inspector-settings_1","title":"Inspector Settings:","text":"<ul> <li>Zero Position: If checked, the chosen prefab will be spawned at the exact position of the marker GameObject, ignoring any positional offset the prefab itself might have relative to its own pivot. If unchecked, the prefab spawns at the marker's position, but offset by the prefab's own internal position (usually (0,0,0), but could be different).</li> <li>Zero Rotation: If checked, the chosen prefab will be spawned with the exact rotation of the marker GameObject, ignoring the prefab's own base rotation. If unchecked, the prefab spawns with the marker's rotation plus the prefab's own base rotation.</li> <li>Prefab Weights: This list holds references to the prefabs (from your Project view) that can be spawned by this component.<ul> <li>Adding Prefabs: Drag prefabs from your Project view onto the list.</li> <li>Weight per Prefab: Each prefab entry has its own weight settings (<code>Main Path</code>, <code>Branch Path</code>, <code>Depth Scale</code>). The effective weight determines the likelihood of each prefab being chosen for instantiation. Refer to the Weighting page for details.</li> </ul> </li> </ul> <p>Outcome: When the Tile containing this marker is placed, the <code>Random Prefab</code> component selects one prefab from its list based on weights and instantiates it at the marker GameObject's position and rotation (potentially modified by the Zero Position/Rotation settings).</p>"},{"location":"advanced-features/props-variety/#global-props","title":"Global Props","text":"<ul> <li>Purpose: To control the total number of a specific category of object across the entire generated dungeon, regardless of how many potential instances exist within the placed Tiles. Useful for ensuring uniqueness (e.g., only one \"Altar of Power\") or controlling scarcity (e.g., between 1 and 3 \"Treasure Chests\").</li> <li>Setup: Add the <code>Global Prop</code> component (<code>Add Component &gt; DunGen &gt; Random Props &gt; Global Prop</code>) directly to the GameObject you want to manage within your Tile prefab (e.g., if you're wanting to limit the number of treasure chests, this should go on the treasure chest instance inside your tile).</li> </ul>"},{"location":"advanced-features/props-variety/#component-inspector-settings","title":"Component Inspector Settings:","text":"<ul> <li>Group ID: A crucial integer identifier. All props that should be counted together must share the same Group ID. (e.g., all potential Treasure Chests might have Group ID <code>1</code>, all Shrines might have Group ID <code>2</code>).</li> <li>Weights (<code>Main Path</code>, <code>Branch Path</code>, <code>Depth Scale</code>): These weights do not determine if the prop spawns initially (it's already part of the Tile). Instead, they act as a priority score. If DunGen places more potential Global Props of a specific Group ID than the allowed maximum (set in the Dungeon Flow, see below), it uses these weights to decide which instances to keep. Higher effective weight means higher priority to survive the culling process. Refer to the Weighting page for details.</li> </ul>"},{"location":"advanced-features/props-variety/#dungeon-flow-configuration","title":"Dungeon Flow Configuration:","text":"<p>The actual limit for each Global Prop category is set in your Dungeon Flow asset:</p> <ol> <li>Select your Dungeon Flow asset in the Project view.</li> <li>Find the Global Props section in the Inspector.</li> <li>Click the + button.</li> <li>Enter the <code>Group ID</code> that matches the <code>Group ID</code> you set on the components in your Tile prefabs.</li> <li>Set the <code>Count</code> (Min/Max) range. This tells DunGen the minimum and maximum number of props with this <code>Group ID</code> that should exist in the final generated dungeon.</li> </ol> <p>Outcome: During the post-processing phase of generation, DunGen gathers all enabled GameObjects that have a <code>Global Prop</code> component. For each unique <code>Group ID</code>, it checks if the total count falls within the Min/Max range defined in the Dungeon Flow asset.</p> <ul> <li>If there are too many props of a certain ID, it discards props at random based on the effective weight (priority) until the count reaches the maximum limit.</li> <li>DunGen currently doesn't enforce the minimum count if too few potential props were placed initially.</li> </ul>"},{"location":"advanced-features/props-variety/#custom-prop-implementation","title":"Custom Prop Implementation","text":"<p>Custom prop behaviour can be achieved by creating a new component derived from the <code>RandomProp</code> abstract class. Simply implement the <code>Process()</code> method and DunGen will automatically call it when processing props.</p> <pre><code>public abstract class RandomProp : MonoBehaviour\n{\n    public abstract void Process(RandomStream randomStream, Tile tile, ref List&lt;GameObject&gt; spawnedObjects);\n}\n</code></pre> <ul> <li>randomStream: The random number generator used to generate the dungeon. This ensures that the same dungeon will be generated again if an identical seed is used.</li> <li>tile: The tile that this prop belongs to.</li> <li>spawnedObjects: An list reference allowing us to let DunGen know if we spawned any objects of our own when processing the prop. This ensures that DunGen can properly process props recursively.</li> </ul> <p>By strategically using these three prop components, you can dramatically increase the replayability and visual diversity of your dungeons without needing an excessive number of base Tile prefabs.</p>"},{"location":"advanced-features/runtime-events/","title":"Advanced Features: Runtime Events &amp; Code Execution","text":"<p>After DunGen has finished generating the dungeon layout, placing tiles, handling props, and potentially running integrations like pathfinding, you'll often need to execute your own custom game logic. This could involve:</p> <ul> <li>Spawning the player character at the start tile.</li> <li>Initializing enemies or interactive objects placed within tile prefabs.</li> <li>Activating global game systems that depend on the dungeon layout.</li> <li>Fading in from a loading screen.</li> </ul> <p>DunGen provides two primary mechanisms to hook into the generation process and run your code once the dungeon is ready:</p> <ol> <li>On Specific Objects: Implement an interface (<code>IDungeonCompleteReceiver</code>) on components attached to GameObjects within your Tile prefabs.</li> <li>Globally: Listen to completion or status change events directly from the <code>DungeonGenerator</code> instance.</li> </ol>"},{"location":"advanced-features/runtime-events/#method-1-on-objects-inside-the-dungeon-idungeoncompletereceiver","title":"Method 1: On Objects Inside the Dungeon (IDungeonCompleteReceiver)","text":"<p>This method is ideal when you want logic to run that is specific to a particular GameObject or prefab placed as part of the dungeon.</p> <p>How it Works:</p> <ol> <li>Create a C# script.</li> <li>Implement the <code>DunGen.IDungeonCompleteReceiver</code> interface in your script.</li> <li>This interface requires you to implement one method: <code>void OnDungeonComplete(Dungeon dungeon)</code>.</li> <li>Attach this script component to a GameObject that is part of one of your Tile prefabs.</li> <li>After DunGen successfully generates the entire dungeon layout, it will search all GameObjects within the final layout for components that implement <code>IDungeonCompleteReceiver</code> and call their <code>OnDungeonComplete</code> method.</li> </ol> <p>Parameters:</p> <ul> <li><code>Dungeon dungeon</code>: Provides access to the data structure representing the completed dungeon layout (containing information about tiles, doorways, paths, etc.).</li> </ul> <p>Example: Spawning an Item or Enemy within a Tile</p> <pre><code>using UnityEngine;\nusing DunGen;\n\n// Attach this script to a GameObject inside one of your Tile prefabs\npublic class PostGenerationSpawner : MonoBehaviour, IDungeonCompleteReceiver\n{\n    // Assign the prefab to spawn in the Inspector\n    public GameObject PrefabToSpawn;\n\n    public void OnDungeonComplete(Dungeon dungeon)\n    {\n        // Check if we actually have a prefab assigned\n        if (PrefabToSpawn == null)\n        {\n            Debug.LogWarning(\"PrefabToSpawn is not set!\", this);\n            return;\n        }\n\n        Debug.Log($\"Dungeon complete! Spawning '{PrefabToSpawn.name}' at {transform.position}\", this);\n\n        // Instantiate the prefab at this GameObject's position and rotation\n        // Parent it to this object's parent (likely the Tile root) for organisation\n        // NOTE: If you're using Tile pooling, you will need to clean up the spawned objects manually\n        GameObject instance = Instantiate(PrefabToSpawn, transform.position, transform.rotation, transform.parent);\n\n        // Optional: You could add logic here to initialize the spawned object\n        // EnemyController enemy = instance.GetComponent&lt;EnemyController&gt;();\n        // if(enemy != null) { enemy.Initialize(); }\n    }\n}\n</code></pre> <p>Use Cases:</p> <ul> <li>Activating specific logic within a room once the whole dungeon is ready.</li> <li>Spawning enemies or items at designated locations within tiles.</li> <li>Initializing puzzle elements placed inside prefabs.</li> </ul>"},{"location":"advanced-features/runtime-events/#method-2-globally-via-generator-events","title":"Method 2: Globally via Generator Events","text":"<p>This method is suitable when you need to run logic that relates to the dungeon generation process as a whole, rather than a specific object within it. You subscribe to an event on the <code>DungeonGenerator</code>.</p> <p>How it Works:</p> <ol> <li>Get a reference to your <code>RuntimeDungeon</code> component and its underlying <code>DungeonGenerator</code> instance.</li> <li>The <code>DungeonGenerator</code> has a delegate/event called <code>OnGenerationComplete</code>.</li> <li>Create a method in your script that matches the required signature: <code>void OnGenerationComplete(DungeonGenerator generator, GenerationStatus status)</code></li> <li>Subscribe your method to the <code>OnGenerationComplete</code> event (using +=).</li> <li>Crucially, remember to unsubscribe from the event (using -=) when your listener object is destroyed or disabled to prevent errors.</li> </ol> <p>Parameters:</p> <ul> <li><code>DungeonGenerator generator:</code> The instance of the generator that fired the event.</li> </ul> <p>Example: Spawning the Player After Dungeon Completion</p> <pre><code>public class GlobalDungeonCompleteListener : MonoBehaviour\n{\n    // Assign your Runtime Dungeon in the Inspector\n    public RuntimeDungeon RuntimeDungeon;\n    // Assign your player prefab in the Inspector\n    public GameObject PlayerPrefab;\n\n\n    private void Start()\n    {\n        if (RuntimeDungeon == null)\n        {\n            Debug.LogError(\"RuntimeDungeon is not assigned!\", this);\n            return;\n        }\n\n        var generator = RuntimeDungeon.Generator;\n\n        // Subscribe to the event\n        generator.OnGenerationComplete += HandleDungeonCompletion;\n\n        // Optional: If generation might already be complete before Start runs\n        // (e.g., if GenerateOnStart was true), check current status.\n        if (generator.Status == GenerationStatus.Complete)\n            HandleDungeonCompletion(generator);\n    }\n\n    void OnDestroy()\n    {\n        // IMPORTANT: Unsubscribe when this object is destroyed\n        if (RuntimeDungeon != null)\n            RuntimeDungeon.Generator.OnGenerationComplete -= HandleDungeonCompletion;\n    }\n\n    private void HandleDungeonCompletion(DungeonGenerator generator)\n    {\n        Debug.Log(\"Dungeon Generation Complete! Spawning Player...\");\n\n        if (PlayerPrefab == null)\n        {\n            Debug.LogError(\"Player Prefab is not assigned!\", this);\n            return;\n        }\n\n        // Get the start tile location from the generated dungeon data\n        if (generator.CurrentDungeon != null)\n        {\n            var startTile = generator.CurrentDungeon.MainPathTiles[0];\n            Vector3 spawnPosition = startTile.transform.position;\n            // You might want to offset this slightly or use a specific spawn point transform within the start tile\n            Instantiate(PlayerPrefab, spawnPosition, Quaternion.identity);\n        }\n        else\n            Debug.LogError(\"Could not find generated dungeon to spawn player!\", this);\n    }\n}\n</code></pre> <p>Use Cases:</p> <ul> <li>Spawning the player character.</li> <li>Initializing global managers or systems after the level is built.</li> <li>Signaling that loading is complete and fading in the game view.</li> </ul>"},{"location":"advanced-features/runtime-events/#choosing-the-right-method","title":"Choosing the Right Method","text":"<ul> <li>Use <code>IDungeonCompleteReceiver</code> for logic tightly coupled to specific prefabs or locations within the dungeon.</li> <li>Use the <code>OnGenerationComplete</code> event for global actions that need to happen once the entire dungeon generation process is finished.</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts: Overview","text":""},{"location":"core-concepts/#asset-types","title":"Asset Types","text":"<ul> <li> <p> Tile</p> <p>The building blocks of your dungeon. Usually a single room or corridor</p> <p>Read More \u2192</p> </li> <li> <p> Tile Set</p> <p>A collection of Tiles to choose from at random</p> <p>Read More \u2192</p> </li> <li> <p> Archetype</p> <p>A type or \u201cbiome\u201d for a dungeon section. Also describes how branching occurs</p> <p>Read More \u2192</p> </li> <li> <p> Dungeon Flow</p> <p>The master graph that controls structure and progression</p> <p>Read More \u2192</p> </li> </ul>"},{"location":"core-concepts/#paths","title":"Paths","text":"<p>There are two types of path in DunGen:</p>"},{"location":"core-concepts/#main-path","title":"Main Path","text":"<p>The primary route or \u201chot path\u201d through your dungeon that goes from the Start tile to the Goal tile.</p> <p>DunGen first creates the Main Path by running through the <code>Dungeon Flow</code> from start to finish. Each step adds a new Tile adjacent to the one created in the previous step, constructing the dungeon one tile at a time. Since the Main Path is considered critical to gameplay, if DunGen fails to generate it following the constraints set, it will backtrack or restart until it succeeds</p> <p>Note</p> <p>In the editor, DunGen will give up if it fails to generate the dungeon a certain number of times to avoid running into an infinite loop. In a packaged build, it will continue until it succeeds</p>"},{"location":"core-concepts/#branch-paths","title":"Branch Paths","text":"<p>One of any number of optional branches coming off the Main Path. These are not meant to be critical to gameplay.</p> <p>Once the Main Path has been generated, DunGen loops back through the dungeon adding Branch Paths to line segments in the graph. If DunGen fails at any point when generating a branch, it will consider the last Tile placed to be the end of that branch and move on.</p>"},{"location":"core-concepts/archetypes/","title":"Core Concepts: Archetypes","text":""},{"location":"core-concepts/archetypes/#what-is-an-archetype","title":"What is an Archetype?","text":"<p>Think of an Archetype as a set of rules or a \"style guide\" for a specific section of your dungeon layout. While Tile Sets define which tiles are available (the palette), Archetypes define how DunGen should behave when building a segment using those tiles.</p> <p>Specifically, an Archetype controls:</p> <ul> <li>Which Tile Sets to use for placing tiles in this section.</li> <li>How optional branches should behave (how many, how long).</li> <li>How much DunGen should try to keep the path straight.</li> </ul>"},{"location":"core-concepts/archetypes/#how-are-archetypes-used","title":"How are Archetypes Used?","text":"<p>Archetypes are primarily assigned to the line segments connecting nodes within the Dungeon Flow graph. When DunGen generates the tiles corresponding to that line segment (either on the main path or branches originating from it), it uses the rules defined in the assigned Archetype.</p> <p>This allows you to easily create distinct sections within your dungeon \u2013 perhaps a crypt section that branches frequently using \"Crypt\" tiles, followed by a straighter castle corridor section using \"Castle\" tiles.</p>"},{"location":"core-concepts/archetypes/#creating-an-archetype","title":"Creating an Archetype","text":"<p>You create Archetype assets directly in your project:</p> <ol> <li>Right-click in the Project view.</li> <li>Navigate to <code>Create &gt; DunGen &gt; Dungeon Archetype</code>.</li> <li>Give your new Archetype asset a descriptive name.</li> </ol>"},{"location":"core-concepts/archetypes/#inspector-settings","title":"Inspector Settings","text":"<p>Selecting an Archetype asset reveals its configuration options in the Inspector:</p>"},{"location":"core-concepts/archetypes/#general","title":"General","text":"<ul> <li>Branching Depth (Min/Max): Defines the minimum and maximum length (number of tiles) for any individual branch path that originates from a tile within this Archetype's section.</li> </ul> <p>Guideline, Not Strict Limit</p> <p>The minimum value is a target, not a guarantee. If DunGen cannot place a branch of the minimum length due to collisions or other constraints, it may create a shorter branch or no branch at all. The maximum value is respected.</p> <ul> <li>Branch Count (Min/Max): Defines the minimum and maximum number of branch paths that can originate from any single tile on the main path while DunGen is processing this Archetype's section.</li> </ul> <p>Per-Tile vs Global</p> <p>This setting is used when the Dungeon Flow's <code>Branch Mode</code> is set to <code>Local</code>. If set to <code>Global</code>, the branch count is managed across the entire dungeon by the Dungeon Flow asset itself.</p> <p>Guideline, Not Strict Limit</p> <p>Similar to Branching Depth, the minimum value is a target. DunGen might not be able to place the minimum number of branches from every tile if space is constrained.</p>"},{"location":"core-concepts/archetypes/#path-straightening","title":"Path Straightening","text":"<p>All settings in this section can be optionally overridden from the <code>Dungeon Flow</code> asset by checking the checkbox next to each field. If the box is unchecked, the default values from the <code>Dungeon Flow</code> will be used instead.</p> <ul> <li>Straighten Chance: A value indicating how strongly DunGen should prioritize placing the next tile directly forward, avoiding turns. Higher values result in straighter, less winding paths. A value of 0 applies no directional preference.</li> <li>Straighten Main Path: Should the path straightening be applied to tiles on the main path?</li> <li>Straighten Branch Paths: Should the path straightening be applied to tiles on branch paths?</li> </ul>"},{"location":"core-concepts/archetypes/#tile-sets","title":"Tile Sets","text":"<ul> <li>List of Tile Sets: This is where you specify which Tile Sets DunGen should use when selecting tiles for this section of the dungeon (both main path and branches).</li> <li>Adding Sets: Click \"Add New\" and drag a Tile Set asset from your Project view into the slot.</li> <li>Selection: DunGen will consider all tiles within all the listed Tile Sets, respecting their individual weights, when choosing the next tile for this section.</li> </ul>"},{"location":"core-concepts/archetypes/#branch-cap-tiles","title":"Branch Cap Tiles","text":"<p>This section allows you to define specific tiles that should be used as \"dead ends\" or caps for branch paths generated within this Archetype.</p> <ul> <li>Branch Cap Type: Controls how the Branch-Cap Tile Sets (below) are used:<ul> <li><code>Instead Of</code>: Only tiles from the \"Branch-Cap Tile Sets\" list below will be considered for the final tile of a branch. The main \"Tile Sets\" list (above) is ignored for this last tile.</li> <li><code>As Well As</code>: Tiles from both the main \"Tile Sets\" list and the \"Branch-Cap Tile Sets\" list are considered for the final tile of a branch.</li> </ul> </li> <li>Branch-Cap Tile Sets: A list of Tile Sets specifically designated for use as branch caps. Click \"Add New\" and assign Tile Set assets here.</li> </ul> <p>Length Dependent</p> <p>DunGen tries to use these caps, but if a branch path ends up being shorter than the configured <code>Branching Depth</code> (due to collisions, etc.), the final tile might not necessarily come from this specific list.</p>"},{"location":"core-concepts/archetypes/#purpose-and-use-cases","title":"Purpose and Use Cases","text":"<p>Archetypes are powerful tools for:</p> <ul> <li>Defining Thematic Sections: Assign different Archetypes with different Tile Sets to consecutive lines in your Dungeon Flow to transition between visual styles (e.g., cave entrance -&gt; crypt -&gt; lava caverns).</li> <li>Controlling Complexity: Create Archetypes with high branching settings for maze-like areas, and others with low/zero branching for straightforward corridors.</li> <li>Pacing: Use Archetypes with simpler tiles and fewer branches early in the dungeon flow, and introduce more complex ones later.</li> <li>Defining Branch Content: Ensure branches use specific types of tiles (e.g., only \"SecretRoom\" tilesets for branches in a certain section).</li> </ul> <p>By combining Archetypes with Tile Sets and arranging them in the Dungeon Flow graph, you gain significant control over the structure, style, and complexity of your generated dungeons.</p>"},{"location":"core-concepts/doorways/","title":"Core Concepts: Doorways","text":""},{"location":"core-concepts/doorways/#what-is-a-doorway","title":"What is a Doorway?","text":"<p>Doorways are the fundamental mechanism DunGen uses to connect your Tiles together. They act as designated attachment points on your Tile prefabs. When generating a dungeon, DunGen attempts to align Doorways from adjacent Tiles to form connections and build the layout.</p> <p>You define potential connection points by adding Doorway components to your Tile prefabs, as initially covered in the Getting Started guide.</p>"},{"location":"core-concepts/doorways/#creating-a-doorway","title":"Creating a Doorway","text":"<ol> <li>Inside your Tile prefab, create an empty GameObject where you want a potential connection to form.</li> <li>Add the Doorway component (<code>Add Component &gt; DunGen &gt; Doorway</code>) to this empty GameObject.</li> <li>Position this empty GameObject precisely (see Placement Rules below).</li> <li>Ensure this Doorway GameObject is a child of your main Tile prefab's root object.</li> </ol>"},{"location":"core-concepts/doorways/#placement-rules","title":"Placement Rules","text":"<p>Correct Doorway placement is crucial for DunGen to function properly.</p> <ul> <li>Edge of Bounds: The Doorway's position must lie on the edge of the Tile's calculated Axis-Aligned Bounding Box (AABB). If a doorway lies inside the bounds, the bounding box will be shrunk to match its position (potentially causing some geometry to protrude outside the bounding box).</li> </ul> <p>Concave Shapes</p> <p>Doorways cannot be placed on concave sections of a Tile's boundary. They must be accessible from outside the Tile's AABB. See the Limitations page for more details.</p> <ul> <li>Orientation (Z-Axis): The Doorway GameObject's local forward (Z) axis (the blue arrow in the Scene view gizmo) must point directly outwards, away from the Tile's interior. This defines the connection direction.</li> <li>Orientation (Y-Axis): By default, the doorway's up axis will point towards positive Y. This is the usual up-vector for 3D scenes, but if you're working in 2D, ensure the Doorway's orientation matches your project's \"up\" direction so connections form correctly in the 2D plane.</li> </ul>"},{"location":"core-concepts/doorways/#the-doorway-component","title":"The Doorway Component","text":"<p>The Doorway component holds all the information DunGen needs about this specific connection point:</p> <ul> <li>Socket: This is perhaps the most important setting for controlling connections. It assigns a Doorway Socket asset to this doorway. See the dedicated Doorway Sockets section below for details.</li> <li>Hide Conditional Objects?: If checked, connector and blocker scene objects will be hidden to reduce clutter in-editor. This setting has no effect at runtime</li> </ul>"},{"location":"core-concepts/doorways/#connectors-blockers","title":"Connectors &amp; Blockers","text":"<p>These sections control what appears at the Doorway's location depending on whether it gets used in the final layout:</p> <ul> <li> <p>Connectors: Objects placed here are enabled or spawned when this Doorway successfully connects to another Doorway on an adjacent Tile.</p> <ul> <li>Use Case: Door frames, open doorways, dynamic Door objects, visual connection flourishes.</li> <li>Priority: If both connecting doorways try to spawn a Connector prefab, the one with the higher priority value wins and its prefab is spawned. If priorities are equal, one is chosen randomly.</li> </ul> </li> <li> <p>Blockers: Objects placed here are enabled or spawned when this Doorway remains unused (is not connected to another Tile).</p> <ul> <li>Use Case: Walls, closed doors, rubble piles, bookcases - anything to block the unused opening.</li> </ul> </li> </ul> <p>Both Connectors and Blockers share these configuration options:</p> <ul> <li>Random Prefab: A list where you can assign prefabs to be potentially spawned at the Doorway's position and orientation. The prefab instance will be attached to the Doorway GameObject.<ul> <li>Weights: Each prefab has a Weight controlling its relative chance of being chosen if multiple prefabs are listed. Only one prefab is chosen per connected doorway pair.</li> <li>Avoid Rotation?: If checked, the spawned prefab will retain its own prefab rotation instead of inheriting the Doorway's rotation. Useful for props that shouldn't rotate with the doorway.</li> </ul> <p>Note</p> <p>For Connectors, one prefab per connected doorway pair will be spawned. For Blockers, one prefab per Doorway component will be spawned.</p> </li> <li>Scene Objects: A list of GameObjects already present within the Tile prefab itself (as children somewhere) that should be enabled/disabled based on the Doorway's connection state.<ul> <li>Unlike prefabs, all GameObjects listed here are affected (enabled if the condition is met, disabled otherwise).</li> </ul> </li> </ul>"},{"location":"core-concepts/doorways/#ensuring-correct-placement-of-doorway-prefabs","title":"Ensuring Correct Placement of Doorway Prefabs","text":"<p>If you're using Connector or Blocker Prefabs (as opposed to Scene Objects), getting the position and rotation right is critical. Since the instantiated prefab will be parented to the Doorway GameObject, it will inherit its position and rotation.</p> <p>While there are options for <code>Position Offset</code> and <code>Rotation Offset</code>, it's better to just create the prefab with the appropriate offsets built-in. Here's a solid process for doing this:</p> <ol> <li>Find an existing Doorway in one of your Tiles.</li> <li>Create a new GameObject and name it appropriately (e.g., \"Standard Doorway Blocker\").</li> <li>Parent the empty GameObject to your Doorway and reset its transform (in the inspector, right-click on <code>Transform</code> and choose <code>Reset</code>).</li> <li>Add the geometry you want to the new GameObject. Move and rotate only the child objects, not the root GameObject. This will ensure that all the geometry will be in the correct place when the prefab is instantiated later.</li> <li>When done, drag the root GameObject into the project view to turn it into a prefab. We don't need it in the scene hierarchy any more so feel free to delete it.</li> <li>Assign the new prefab to one of the lists as described earlier.</li> </ol>"},{"location":"core-concepts/doorways/#tags","title":"Tags","text":"<ul> <li>Functionality: Allows you to assign one or more custom tags to this Doorway.</li> <li>Purpose: These tags are used by custom Tile Connection Rules to allow or deny connections between specific tiles based on the type of doorways DunGen is trying to connect. Tags are extremely versatile and can be used for any number of purposes in your own code.</li> </ul>"},{"location":"core-concepts/doorways/#doorway-sockets","title":"Doorway Sockets","text":""},{"location":"core-concepts/doorways/#purpose","title":"Purpose","text":"<p>Doorway Sockets are identifier assets used to filter potential connections. By default, DunGen will only connect two Doorways if they both share the exact same Socket asset.</p> <p>This is essential for:</p> <ul> <li>Different Sizes: Preventing a small doorway from connecting to a large one. Create separate Socket assets like \"Small Archway Socket\" and \"Large Archway Socket\" and assign them accordingly.</li> <li>Different Styles: Ensuring a \"Cave Mouth\" doorway only connects to another \"Cave Mouth\", not a \"Castle Door\".</li> <li>Special Connections: Defining unique sockets for specific connection types, like ladders or teleporters, that shouldn't connect to standard doorways.</li> </ul>"},{"location":"core-concepts/doorways/#default-socket","title":"Default Socket","text":"<p>DunGen includes a \"Default\" socket. If all your doorways are identical in size and type, you can simply use this default socket for all of them.</p>"},{"location":"core-concepts/doorways/#creating-custom-sockets","title":"Creating Custom Sockets","text":"<p>If you need different types of connections:</p> <ol> <li>Right-click in the Project view.</li> <li>Navigate to <code>Create &gt; DunGen &gt; Doorway Socket</code>.</li> <li>Give the new Socket asset a descriptive name.</li> <li>Assign this new Socket asset to the <code>Socket Group</code> field on the relevant Doorway components in your Tile prefabs.</li> </ol>"},{"location":"core-concepts/doorways/#overriding-matching-behaviour","title":"Overriding Matching Behaviour","text":"<p>While default behaviour requires sockets to match exactly, you can implement more complex logic using Code-Based Connection Rules.</p> <p>Doorways, combined with Sockets and their Connector/Blocker configurations, are the core elements that allow DunGen to intelligently piece together your pre-designed Tiles into coherent and varied dungeon layouts.</p>"},{"location":"core-concepts/dungeon-flow/","title":"Core Concepts: Dungeon Flow Asset","text":""},{"location":"core-concepts/dungeon-flow/#what-is-a-dungeon-flow","title":"What is a Dungeon Flow?","text":"<p>The Dungeon Flow asset is the master blueprint for your entire dungeon layout. It orchestrates the high-level structure, defining the sequence of different sections, the overall length, branching behaviour, and connections to other systems like Locks &amp; Keys or Tile Injection.</p> <p>Think of it as the top-level director telling DunGen how to assemble the dungeon using the Tile Sets and Archetypes you've defined. It uses a visual graph interface, the Flow Editor, to represent this structure.</p> <p>Every DunGen generation process starts with a Dungeon Flow asset.</p>"},{"location":"core-concepts/dungeon-flow/#creating-a-dungeon-flow-asset","title":"Creating a Dungeon Flow Asset","text":"<p>You create Dungeon Flow assets directly in your project:</p> <ol> <li>Right-click in the Project view.</li> <li>Navigate to <code>Create &gt; DunGen &gt; Dungeon Flow</code>.</li> <li>Give your new Dungeon Flow asset a descriptive name.</li> </ol>"},{"location":"core-concepts/dungeon-flow/#inspector-settings","title":"Inspector Settings","text":"<p>Selecting a Dungeon Flow asset reveals its configuration options in the Inspector:</p> <ul> <li>Validate Dungeon: (Button) Runs a series of checks on the Dungeon Flow and its referenced assets (Tile Sets, Archetypes, Nodes) to help identify potential configuration issues that might prevent successful dungeon generation.</li> <li>Key Manager: Assigns a Key Manager asset to enable the Lock &amp; Key system for this dungeon flow. (See Advanced Features for details).</li> <li>Length (Min/Max): Defines the minimum and maximum number of tiles that should make up the main path of the dungeon (from the start node to the goal node). DunGen will attempt to generate a main path within this length range.</li> </ul>"},{"location":"core-concepts/dungeon-flow/#doorway-connection","title":"Doorway Connection","text":"<ul> <li>Connection Chance: A percentage (0-1) determining the likelihood that two unconnected but spatially overlapping doorways will be connected by DunGen. This can create potential shortcuts or loops if set above 0.</li> <li>Restrict to Same Section: If checked, connections created by the <code>Connection Chance</code> can only occur between doorways on tiles belonging to the same line segment in the Flow Editor graph. This prevents accidental shortcuts bypassing major sections defined in the flow.</li> </ul>"},{"location":"core-concepts/dungeon-flow/#path-straightening","title":"Path Straightening","text":"<p>Global settings for defining how straight paths should be. These can be overridden on individual Archetypes and on nodes in the Flow Graph Editor.</p> <ul> <li>Straighten Chance: A value indicating how strongly DunGen should prioritize placing the next tile directly forward, avoiding turns. Higher values result in straighter, less winding paths. A value of 0 applies no directional preference.</li> <li>Straighten Main Path: Should the path straightening be applied to tiles on the main path?</li> <li>Straighten Branch Paths: Should the path straightening be applied to tiles on branch paths?</li> </ul>"},{"location":"core-concepts/dungeon-flow/#branching","title":"Branching","text":"<ul> <li>Branch Mode: Determines how the total number of branches in the dungeon is calculated:<ul> <li><code>Local</code>: The number of branches is calculated per-tile using the <code>Branch Count</code> settings from the owning Archetype.</li> <li><code>Global</code>: The <code>Branch Count (Min/Max)</code> setting defined here (directly below the Branch Mode setting) controls the total number of branches across the entire dungeon. Archetype <code>Branch Count</code> settings are ignored.</li> <li><code>Section</code>: Each line segment in the flow graph will have the desired number of branches specified in the <code>Branch Count</code> property of the segment's Archetype.</li> </ul> </li> <li>Branch Count (Min/Max) (Visible if Global): Defines the target minimum and maximum number of branches across the entire dungeon.</li> <li>Branch Prune Mode: The method by which tiles at the end of a branch are removed based on the tags below.<ul> <li><code>Any Tags Present</code>: Tiles at the end of a branch will be removed if any of the following tags are present. Useful for tagging tiles with a <code>Corridor</code> tag to avoid branches terminating in a corridor.</li> <li><code>All Tags Missing</code>: Tiles at the end of a branch will be removed if it doesn't have any of the following tags. E.g. For if you want only tiles tagged as <code>End Cap</code>, <code>Shop</code>, or <code>Secret Room</code> to terminate branches.</li> </ul> </li> <li>Branch Prune Tags: Allows you to specify Tile Tags that should cause a tile to be deleted if it appears at the very end (dead end) of a branch path. Useful for preventing inappropriate tiles (like simple corridor pieces) from being branch terminators. Tiles are removed based on the <code>Branch Prune Mode</code> above.</li> <li>Special Tile Injection: Configure rules to inject specific tiles from designated Tile Sets at certain points in the dungeon layout. (See Injecting Special Tiles for details).</li> <li>Global Props: Define the minimum and maximum number of specific Global Props that should appear across the entire dungeon. (See Advanced Features for details).</li> <li>Tile Connection Rules: Define rules based on Tile Tags to explicitly allow or deny connections between certain types of tiles (e.g., prevent corridors from connecting only to other corridors). (See Tile Connection Rules for details).</li> <li>Open Flow Editor: (Button) Opens the visual graph editor associated with this Dungeon Flow asset.</li> </ul> <p>The Dungeon Flow asset ties all these pieces together, making it the central configuration point referenced by the Dungeon Generator component at runtime.</p>"},{"location":"core-concepts/dungeon-generator/","title":"Core Concepts: Dungeon Generator","text":""},{"location":"core-concepts/dungeon-generator/#overview","title":"Overview","text":"<p>The Dungeon Generator is the engine responsible for taking all your configuration (from the Dungeon Flow, Archetypes, Tile Sets, etc.) and actually building the dungeon layout in your scene.</p> <p>While you can trigger generation manually through code or via an editor window (<code>Window &gt; DunGen &gt; Generate Dungeon</code>), the most common way to handle generation at runtime is by using the Runtime Dungeon component.</p> <p>You add this component to a GameObject in your scene (<code>Add Component &gt; DunGen &gt; Runtime Dungeon</code>). This GameObject then becomes the central point for controlling and triggering the dungeon generation process for that specific dungeon instance.</p>"},{"location":"core-concepts/dungeon-generator/#runtime-dungeon-component-settings","title":"Runtime Dungeon Component Settings","text":"<p>Here are the settings available in the <code>Runtime Dungeon</code> component's Inspector:</p> <ul> <li> <p>Generate on Start:</p> <ul> <li>If checked, the dungeon generation process will automatically begin as soon as the scene starts (in the <code>Start()</code> method). If unchecked, you'll need to trigger generation manually via code or another system (like PlayMaker).</li> </ul> </li> <li> <p>Root:</p> <ul> <li>An optional GameObject reference. If assigned, the generated dungeon's root GameObject (containing all the placed Tiles) will be parented under this object in the scene hierarchy. If left as <code>None</code>, DunGen will create a new root GameObject named \"Dungeon\".</li> </ul> </li> <li> <p>Dungeon Flow:</p> <ul> <li>Required. Assign the Dungeon Flow asset that defines the structure and rules for the dungeon you want to generate. This is the master blueprint the generator follows.</li> </ul> </li> <li> <p>Max Failed Attempts:</p> <ul> <li>Specifies the maximum number of times DunGen is allowed to completely fail and restart the generation process in the editor before giving up. This prevents infinite loops during design if constraints are too strict.</li> </ul> </li> </ul> <p>Runtime Behaviour</p> <p>In a standalone build (not the Unity Editor), DunGen will keep retrying indefinitely until it succeeds, ignoring this setting to ensure a dungeon is always generated eventually.</p> <ul> <li> <p>Length Multiplier:</p> <ul> <li>A multiplier applied to the <code>Length</code> range defined in the assigned <code>Dungeon Flow</code> asset.</li> <li><code>1</code> = Use the length as defined in the Dungeon Flow.</li> <li><code>2</code> = Double the target length range.</li> <li><code>0.5</code> = Halves the target length range.</li> <li>This allows you to easily scale the dungeon size without modifying the Dungeon Flow asset itself.</li> </ul> </li> <li> <p>Up Direction:</p> <ul> <li>Defines the primary \"up\" axis for the dungeon layout (usually <code>+Y</code> for 3D, and <code>-Z</code> for top-down 2D). This primarily affects the placement logic for vertically oriented doorways, ensuring they connect correctly relative to the dungeon's intended orientation. It does not rotate the entire generated dungeon.</li> </ul> </li> <li> <p>Debug Render:</p> <ul> <li>If checked, coloured bounding boxes will be rendered around each Tile in the Scene view after generation is complete.<ul> <li>Main Path: Tiles are coloured from Red (near Start) to Green (near Goal).</li> <li>Branch Paths: Tiles are coloured from Blue (near branch start) to Purple (near branch end).</li> </ul> </li> <li>Useful for visualizing the generated layout structure and debugging path generation.</li> </ul> </li> </ul>"},{"location":"core-concepts/dungeon-generator/#asynchronous-generation","title":"Asynchronous Generation","text":"<p>Settings related to generating the dungeon over multiple frames to avoid freezing the game.</p> <ul> <li>Generate Asynchronously:<ul> <li>If checked, the dungeon generation process will be spread across multiple frames instead of happening all at once. This prevents the game from hanging during potentially long generation times, allowing loading screens or animations to continue playing.</li> </ul> </li> </ul> <p>Note</p> <p>Asynchronous generation might take slightly longer overall compared to synchronous generation.</p> <ul> <li> <p>Max Frame Time:</p> <ul> <li>(Only used if <code>Generate Asynchronously</code> is checked). The maximum time (in milliseconds) that DunGen is allowed to spend on generation tasks within a single frame. Lower values lead to better game responsiveness during generation but increase the total generation time. Higher values shorten total generation time but might cause noticeable frame stutters.</li> </ul> </li> <li> <p>Pause Between Rooms:</p> <ul> <li>(Only used if <code>Generate Asynchronously</code> is checked). An optional delay (in seconds) to pause after placing each room. Primarily useful for visualizing the step-by-step generation process for debugging purposes. Set to <code>0</code> for normal asynchronous generation. This is automatically disabled in standalone builds.</li> </ul> </li> </ul>"},{"location":"core-concepts/dungeon-generator/#collision","title":"Collision","text":"<p>Settings controlling how tiles interact spatially.</p> <ul> <li> <p>Trigger Placement:</p> <ul> <li>If enabled, DunGen will automatically add a <code>BoxCollider</code> (or <code>BoxCollider2D</code>) component as a trigger to the root of each placed Tile prefab. These triggers encompass the bounds of the tile. This should be set to match the type of dungeon you're making (2D or 3D).</li> <li>Can be used in conjunction with the DunGen Character Component or your own scripts to detect when an object enters/exits a specific tile area.</li> </ul> </li> <li> <p>Trigger Layer:</p> <ul> <li>Specifies the physics layer on which the auto-generated <code>Tile Triggers</code> (if enabled above) should be placed.</li> </ul> </li> <li> <p>Overlap Threshold:</p> <ul> <li>A small value determining how much two connected tiles are allowed to overlap spatially. Usually doesn't need changing.</li> </ul> </li> <li> <p>Collide All Dungeons:</p> <ul> <li>If checked, DunGen will check for collisions against tiles from all previously generated dungeons in the scene, not just the tiles within the dungeon currently being generated. Useful if you have multiple independent DunGen instances active.</li> </ul> </li> <li> <p>Disallow Overhangs?:</p> <ul> <li>If checked, tiles are prevented from being placed vertically above or below other tiles if their X/Z bounds overlap.</li> </ul> </li> <li> <p>Padding:</p> <ul> <li>The minimum amount of empty space that must exist between the bounding boxes of any two unconnected tiles. Helps prevent unwanted visual overlap and clutter.</li> </ul> </li> </ul>"},{"location":"core-concepts/dungeon-generator/#constraints","title":"Constraints","text":"<p>Settings for restricting where tiles can be placed.</p> <ul> <li> <p>Restrict to Bounds?:</p> <ul> <li>If checked, DunGen will only place tiles within the volume defined by the <code>Placement Bounds</code> below.</li> </ul> </li> <li> <p>Placement Bounds:</p> <ul> <li>(Only used if <code>Restrict to Bounds?</code> is checked). Defines a world-space bounding box (Center and Extents) outside of which no tiles can be generated.</li> </ul> </li> </ul> <p>Warning</p> <p>Using bounds restrictions can significantly increase the chance of generation failure if the bounds are too small for the requested dungeon length and complexity. It may also increase generation time.</p>"},{"location":"core-concepts/dungeon-generator/#global-overrides","title":"Global Overrides","text":"<p>These settings allow you to optionally override specific behaviours for all tiles generated by this component, regardless of their individual Tile Component settings. If an override is not enabled, the behaviour is determined per-tile.</p> <p></p> <p>The checkbox to the left of the setting determines whether the override is active or not.</p> <ul> <li> <p>Repeat Mode:</p> <ul> <li>Forces all tiles to adhere to a specific repeat mode (<code>Allow</code>, <code>Disallow Immediate</code>, <code>Disallow</code>), overriding any <code>Repeat Mode</code> set on individual Tile components. Defaults to <code>Allow</code>. See Repeat Mode on the Tiles page for details.</li> </ul> </li> <li> <p>Allow Tile Rotation:</p> <ul> <li>Forces all tiles to either allow rotation or disallow rotation, overriding any <code>Allow Rotation</code> setting on individual Tile components.</li> </ul> </li> </ul> <p>The <code>Runtime Dungeon</code> component is the primary interface for launching and controlling the DunGen process within your game scene.</p>"},{"location":"core-concepts/flow-editor/","title":"Core Concepts: Flow Editor","text":""},{"location":"core-concepts/flow-editor/#what-is-the-flow-editor","title":"What is the Flow Editor?","text":"<p>The Flow Editor is the visual graph interface associated with a Dungeon Flow Asset. It provides a graphical way to define the high-level structure and sequence of the dungeon's main path.</p> <p>You access it by selecting a Dungeon Flow asset in your Project view and clicking the \"Open Flow Editor\" button in the Inspector.</p> <p></p> <p>Default dungeon flow</p>"},{"location":"core-concepts/flow-editor/#understanding-the-graph","title":"Understanding the Graph","text":"<p>The graph represents the intended progression through your dungeon's critical path:</p> <ul> <li>Nodes (Boxes): Represent specific, single tile placements along the main path.<ul> <li>Start Node (Red): The fixed starting point of the dungeon. The first tile generated.</li> <li>Goal Node (Green): The fixed endpoint of the main path. The last tile generated.</li> <li>Intermediate Nodes (White): Optional nodes you can add to create distinct milestones within the dungeon flow.</li> </ul> </li> <li>Line Segments (Lines): Represent the sequence of tiles generated between two connected nodes. The actual number of tiles in a segment depends on the overall dungeon <code>Length</code> (set in the Dungeon Flow asset) and the relative visual length of the segments in the editor.</li> </ul>"},{"location":"core-concepts/flow-editor/#interacting-with-the-flow-editor","title":"Interacting with the Flow Editor","text":"<ul> <li>Selecting Elements: Click on a Node or a Line Segment in the graph. The Unity Inspector window will update to show the configuration options specific to that selected element.</li> <li>Adding Nodes: Right-click anywhere along a Line Segment. This will insert a new Intermediate Node at that point.</li> <li>Splitting Lines: Right-click anywhere along a Line Segment. This will split the segment at that point. This is how you create more complex flows with multiple distinct sections.</li> </ul> <p>Right-clicking to add a new node or split a line</p>"},{"location":"core-concepts/flow-editor/#configuring-nodes-and-lines","title":"Configuring Nodes and Lines","text":"<p>The real power comes from configuring what happens at each stage:</p>"},{"location":"core-concepts/flow-editor/#selecting-a-node-start-goal-or-intermediate","title":"Selecting a Node (Start, Goal, or Intermediate)","text":"<p>When a Node is selected, the Inspector allows you to configure:</p> <ul> <li>Label: A cosmetic name for the node in the editor (doesn't affect generation).</li> <li>Tile Sets: Assign one or more Tile Sets here. DunGen will randomly select a single tile from one of these assigned sets to place at this specific node location.</li> <li>Straighten Chance: An optional override to determine how much the path should be straightened. If the checkbox is unchecked, the default setting is used from the Dungeon Flow Asset</li> <li>Keys / Locks: Assign specific Keys or Locks to be placed within this single node tile. (Requires Lock &amp; Key System setup).</li> <li>Lock Placement: (Nodes only) Specify where on the node's tile a lock should be placed (e.g., only on its entrance doorway).</li> </ul>"},{"location":"core-concepts/flow-editor/#selecting-a-line-segment","title":"Selecting a Line Segment","text":"<p>When a Line Segment is selected, the Inspector allows you to configure:</p> <ul> <li>Archetypes: Assign one or more Archetypes here. DunGen will use the rules (branching, Tile Sets specified within the Archetype) defined in one of the assigned Archetypes to generate the sequence of tiles along this segment. If multiple Archetypes are listed, one is chosen randomly per segment.</li> <li>Keys / Locks: Assign Keys or Locks to be placed randomly somewhere along the tiles generated for this line segment. (Requires Lock &amp; Key System setup).</li> <li>Count: (Locks on Lines only) Specify how many instances of the listed lock type should be placed along this segment.</li> </ul>"},{"location":"core-concepts/flow-editor/#example-multi-stage-dungeon","title":"Example: Multi-Stage Dungeon","text":"<p>By adding intermediate nodes, you can create flows like this:</p> <p></p> <p>Multi-Stage dungeon flow</p> <p>This graph tells DunGen:</p> <ol> <li>Start with a tile from the \"Start\" Node's Tile Set(s).</li> <li>Generate a sequence of tiles using the rules from the first Line Segment's Archetype(s).</li> <li>Place a specific tile from the \"MiniBoss\" Node's Tile Set(s).</li> <li>Generate the next sequence using the second Line Segment's Archetype(s).</li> <li>Place a specific tile from the \"Boss\" Node's Tile Set(s).</li> <li>Place the final tile from the \"Goal\" Node's Tile Set(s).</li> </ol>"},{"location":"core-concepts/flow-editor/#why-use-the-flow-editor","title":"Why Use the Flow Editor?","text":"<p>The Flow Editor provides a clear, visual way to:</p> <ul> <li>Define the overall progression of your dungeon's main path.</li> <li>Break the dungeon into distinct sections with different themes or rules (using different Archetypes on lines).</li> <li>Place specific \"milestone\" rooms or tiles at key points (using Nodes).</li> <li>Integrate systems like Locks &amp; Keys at specific structural points.</li> </ul> <p>It translates your high-level design intent into concrete instructions for the DunGen generator.</p>"},{"location":"core-concepts/tile-sets/","title":"Core Concepts: Tile Sets","text":""},{"location":"core-concepts/tile-sets/#what-is-a-tile-set","title":"What is a Tile Set?","text":"<p>Tile Sets are essentially named groupings or collections of your Tile prefabs. Think of them as palettes or inventories of rooms and corridors that DunGen can draw from during generation.</p> <p>Their main purpose is to help you organize your tiles and control which specific sets of tiles can be used in different parts of your dungeon or for different structural roles.</p> Tile Sets vs. Archetypes <p>It's important to understand the difference:</p> <ul> <li>Tile Set: A collection of Tile prefabs</li> <li>Archetype: A set of rules defining a section of the dungeon (branching behaviour, length, etc.) which uses one or more Tile Sets</li> </ul> <p>You can create as many Tile Sets as you need to categorize your content effectively.</p>"},{"location":"core-concepts/tile-sets/#how-are-tile-sets-used","title":"How are Tile Sets Used?","text":"<p>Tile Sets act as the source for Tile selection in several key areas of DunGen:</p> <ol> <li>Dungeon Flow Nodes: You assign Tile Sets directly to the Start, Goal, and any intermediate Nodes in your Dungeon Flow graph. This dictates which specific tiles can be used for those critical single-tile placements.</li> <li>Archetypes: Archetypes define which Tile Set(s) should be used when generating the segments of the dungeon they control (both main path lines and branches).</li> <li>Tile Injection: When using the Tile Injection feature, you specify a Tile Set from which the injected tile should be randomly chosen.</li> <li>Branch Caps: Archetypes allow assigning specific Tile Sets to use for the final tile at the end of a branch path.</li> </ol>"},{"location":"core-concepts/tile-sets/#creating-a-tile-set","title":"Creating a Tile Set","text":"<p>You create Tile Set assets directly in your project:</p> <ol> <li>Right-click in the Project view.</li> <li>Navigate to <code>Create &gt; DunGen &gt; Tile Set</code>.</li> <li>Give your new Tile Set asset a descriptive name (e.g., \"Crypt_Corridors\", \"Castle_LargeRooms\", \"StartTiles\").</li> </ol>"},{"location":"core-concepts/tile-sets/#inspector-settings","title":"Inspector Settings","text":"<p>Selecting a Tile Set asset reveals its configuration options in the Inspector:</p>"},{"location":"core-concepts/tile-sets/#tile-weights","title":"Tile Weights","text":"<p>This is the main part of the Tile Set, where you list the Tile prefabs included in this collection and configure their selection likelihood.</p> <ul> <li>Adding Tiles: Tiles can be added in one of two ways:<ol> <li>Click the \"Add New Tile\" button. Drag a Tile prefab from your Project view into the \"None (GameObject)\" slot that appears.</li> <li>Drag a Tile prefab from your Project view directly onto the \"Add New Tile\" button.</li> </ol> </li> <li>Weights per Tile: Each Tile entry has its own weight settings:<ul> <li>Main Path: The base chance of this tile being chosen when this Tile Set is used for the dungeon's main path.</li> <li>Branch Path: The base chance of this tile being chosen when this Tile Set is used for an optional branch path.</li> <li>Depth Mode: How the base weight is modified by the <code>Depth Scale</code> curve below.</li> <li>Depth Scale: A curve that modifies the Main/Branch path weight based on the tile's normalized depth (0=start, 1=end) along the current path.</li> <li>(For a full explanation of how these weights interact, see the Weighting page).</li> </ul> </li> </ul> <p>Tile Reusability</p> <p>A single Tile prefab can be included in multiple different Tile Sets, potentially with different weights in each set. This is great for organization (e.g., a standard corridor might be in both \"Crypt_Corridors\" and \"Castle_Corridors\" Tile Sets).</p>"},{"location":"core-concepts/tile-sets/#locked-door-prefabs","title":"Locked Door Prefabs","text":"<p>This section allows you to define which prefabs DunGen should use when it needs to place a locked door involving a Tile from this Tile Set. This is part of the Lock &amp; Key System.</p> <ul> <li>Adding Entries: Click the <code>+</code> button under <code>Lock Prefabs</code> to create a new entry for a specific Doorway Socket type.</li> <li>Socket Type: Select the Doorway Socket asset this entry applies to from the dropdown.</li> <li>Prefab Weights: Click the <code>+</code> button on the <code>Prefabs</code> list within the socket entry. Drag your locked door prefab(s) here.<ul> <li>If you add multiple prefabs for the same socket type, their individual weights determine the chance of each one being chosen when a locked door of that socket type is needed.</li> </ul> </li> </ul>"},{"location":"core-concepts/tile-sets/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Start/Goal Rooms: Create Tile Sets like \"StartRooms\" and \"GoalRooms\" containing only the specific prefabs suitable for the dungeon's entrance and exit, then assign these to the Start/Goal nodes in the Dungeon Flow.</li> <li>Thematic Sections: Organize tiles by visual theme (e.g., \"CryptTiles\", \"CaveTiles\", \"CastleTiles\") and assign them to different Archetypes used along the Dungeon Flow graph.</li> <li>Structural Roles: Separate corridors from rooms (e.g., \"CorridorSet\", \"RoomSet\") to potentially use different Archetype rules or weights for each.</li> <li>Difficulty Tiers: Create Tile Sets for different challenge levels (e.g., \"EasyRooms\", \"HardRooms\") and use weights or the Dungeon Flow to introduce harder rooms later in the dungeon.</li> </ul> <p>By effectively using Tile Sets, you gain precise control over which pieces DunGen uses where, enabling better organization and more structured procedural generation.</p>"},{"location":"core-concepts/tiles/","title":"Core Concepts: Tiles &amp; Tile Component","text":""},{"location":"core-concepts/tiles/#what-is-a-tile","title":"What is a Tile?","text":"<p>Tiles are the fundamental building blocks of your dungeons. Think of them as reusable room prefabs, corridor segments, or any distinct piece of level geometry that DunGen will piece together.</p> <p>You design these Tiles visually within the Unity editor, just like any other prefab. DunGen's power comes from how it connects these pre-designed pieces based on rules you define.</p>"},{"location":"core-concepts/tiles/#the-tile-component","title":"The Tile Component","text":"<p>The <code>Tile</code> component provides DunGen with specific metadata and allows you to override certain global generation settings on a per-tile basis.</p>"},{"location":"core-concepts/tiles/#tile-component-settings","title":"Tile Component Settings","text":"<p>Here are the key settings available on the <code>Tile</code> component inspector:</p>"},{"location":"core-concepts/tiles/#allow-rotation","title":"Allow Rotation","text":"<ul> <li>Functionality: If checked, DunGen is allowed to rotate this Tile 90, 180, or 270 degrees around its Y-axis (up-axis) to match the orientation of an adjacent Tile's doorway.</li> <li>When to Uncheck: You should uncheck this if your Tile:<ul> <li>Is designed for an isometric or fixed perspective where rotation would break the visual style.</li> <li>Has a specific \"back wall\" or orientation that must be preserved.</li> </ul> </li> </ul> <p>Global Override</p> <p>The Dungeon Generator component has a global <code>Allow Tile Rotation</code> setting. If you need to disable rotation for all tiles, use the global setting instead of configuring each tile individually.</p>"},{"location":"core-concepts/tiles/#repeat-mode","title":"Repeat Mode","text":"<ul> <li>Functionality: Determines how DunGen handles placing multiple instances of this specific Tile prefab within a single dungeon layout.</li> <li>Options:<ul> <li><code>Allow</code>: No restrictions. All repetition is allowed.</li> <li><code>Disallow Immediate</code>: This Tile can appear multiple times in the dungeon, but never directly connected to another instance of the same Tile prefab.</li> <li><code>Disallow</code>: This Tile prefab can appear at most once in the entire generated dungeon layout.</li> </ul> </li> </ul> <p>Use <code>Disallow</code> Carefully</p> <p>If you use <code>Disallow</code> mode, ensure you have enough unique Tile prefabs available in your Tile Sets for the configured dungeon length. Otherwise, DunGen might fail to generate a valid layout if it runs out of non-repeating tiles.</p> <p>Global Override</p> <p>The Dungeon Generator component has a global <code>Repeat Mode</code> override setting that applies to all tiles.</p>"},{"location":"core-concepts/tiles/#manual-tile-bounds","title":"Manual Tile Bounds","text":"<ul> <li>Functionality: By default, DunGen calculates the physical boundaries (an Axis-Aligned Bounding Box - AABB) of a Tile based on the objects within its hierarchy. Checking this box allows you to manually define the bounds used for collision detection during generation. See the Tile Bounds section for more information.</li> <li>When to Use: Useful if the automatic bounds calculation isn't accurate for your Tile's effective space, perhaps due to complex shapes or invisible helper objects affecting the bounds.</li> </ul> <p>Note</p> <p>The Fit to Tile button can be used to match the overridden bounds to what DunGen's automatic calculation would be, giving you a starting point for manual adjustments.</p>"},{"location":"core-concepts/tiles/#override-connection-chance","title":"Override Connection Chance","text":"<ul> <li>Functionality: Allows this specific Tile to override the global <code>Connection Chance</code> set in the Dungeon Flow asset. This chance determines the likelihood of DunGen connecting two otherwise unconnected doorways that happen to overlap spatially (potentially creating shortcuts or loops).</li> </ul> <p>Interaction</p> <p>If two tiles with overlapping doorways both have this override enabled, the lower of the two percentage chances will be used.</p>"},{"location":"core-concepts/tiles/#entrance-exit-doorways","title":"Entrance / Exit Doorways","text":"<ul> <li>Functionality: You can optionally designate specific Doorway GameObjects within this Tile as the required entry or primary exit points.</li> <li>Entrance:<ul> <li>If set, DunGen must connect to this specific Doorway when placing this Tile. The Tile can only be entered through this doorway.</li> <li>If unset (None), DunGen can enter the Tile through any available Doorway.</li> </ul> </li> <li>Exit:<ul> <li>If set, DunGen must use this specific Doorway as the first point of exit when pathing continues from this Tile.</li> <li>If unset (None) or once the exit is already in use, DunGen can exit the Tile through any available Doorway.</li> </ul> </li> <li>Use Cases: Essential for controlling flow within complex tiles or ensuring specific placements, such as positioning a locked door (related to the Lock &amp; Key System) correctly at the entrance of a boss room.</li> </ul>"},{"location":"core-concepts/tiles/#tags","title":"Tags","text":"<ul> <li>Functionality: Allows you to assign one or more custom tags to this Tile.</li> <li>Purpose: These tags are used by the Tile Connection Rules system (configured in the Dungeon Flow asset) to allow or deny connections between specific types of tiles (e.g., preventing two \"Corridor\" tagged tiles from connecting directly). Tags are extremely versatile and can be used for any number of purposes in your own code.</li> </ul>"},{"location":"core-concepts/tiles/#tile-bounds","title":"Tile Bounds","text":"<p>The bounds of a <code>Tile</code> are computed as an axis-aligned bounding box (AABB) around a tile's contents. These bounds are used during generation to detect collisions and prevent tiles from overlapping. Bounds can be recalculated using the <code>Recalculate Bounds</code> button at the bottom of the tile component's inspector.</p> <p>Common Issues</p> <p>If tiles overlap unexpectedly or fail to generate, incorrect tile bounds are often the cause. Try recalculating the tile's bounds, or set them manually.</p>"},{"location":"core-concepts/tiles/#automatic-tile-bounds","title":"Automatic Tile Bounds","text":"<p>By default, a tile's bounds are automatically recalculated every time the prefab changes. You can disable this behaviour by unchecking <code>Recalculate On Save</code> in the DunGen project settings. This is useful for complex tiles where bounds recalculation causes noticeable editor slowdowns.</p> <p>Missing bounds can also be recalculated across your entire project using the <code>Calculate Missing Tile Bounds</code> button in the DunGen project settings.</p>"},{"location":"core-concepts/tiles/#manual-tile-bounds_1","title":"Manual Tile Bounds","text":"<p>If the automatic tile bounds aren't working for one of your tiles, you can manually set the bounding box by checking the <code>Manual Tile Bounds</code> checkbox in the tile inspector.</p> <p></p> <p>This enables three ways to define the bounds:</p> <ol> <li>Manually entering Center and Extent values</li> <li>Adjusting the red bounding box gizmo in the Scene view</li> <li>Clicking <code>Fit to Tile</code> to run the automatic calculation and apply the result</li> </ol>"},{"location":"core-concepts/tiles/#configuring-bounds-calculations","title":"Configuring Bounds Calculations","text":"<p>Automatic tile bounds calculations can be configured globally in DunGen's project settings.</p> <p></p> <p>The default bounds calculator includes several settings that control which objects contribute to a tile's bounds (marked as box B in the above image).</p>"},{"location":"core-concepts/tiles/#per-tile-bounds-configuration","title":"Per-Tile Bounds Configuration","text":"<p>In some cases, individual tiles may require different bounds behaviour than the global settings provide.</p> <p>It's possible to configure how bounds are calculated on a per-tile basis by attaching an override component to your tile prefab <code>Add Component &gt; DunGen &gt; Tile Bounds Override</code>, or by adding a component to the tile prefab that implements the <code>ITileBoundsCalculator</code> interface.</p>"},{"location":"core-concepts/tiles/#custom-bounds-calculator","title":"Custom Bounds Calculator","text":"<p>Custom logic for calculating tile bounds can be provided by simply creating a new C# class that implements the <code>ITileBoundsCalculator</code> interface and implements <code>CalculateLocalBounds()</code>.</p> <p>This class will automatically appear in the bounds calculator drop-down in DunGen's project settings (box A in the image above). Selecting it will apply your custom logic globally to all tiles, unless a tile explicitly overrides it with a per-tile configuration.</p> Custom Bounds Calculator <pre><code>using DunGen.TileBounds;\nusing UnityEngine;\n\npublic class MyCustomBoundsCalculator : ITileBoundsCalculator\n{\n    // Any serializable fields defined here will be exposed in the project settings\n\n    public Bounds CalculateLocalBounds(GameObject tileRoot)\n    {\n        // Custom bounds calculation logic here\n    }\n}\n</code></pre> <p>If you only need to filter out specific objects but otherwise keep the existing behaviour, you could instead derive a new class from <code>DefaultTileBoundsCalculator</code> and override the <code>ShouldUseComponentBounds()</code> method as demonstrated below:</p> Custom Object Filtering <p>In this example, we filter out any component whose GameObject does not have the required tag.</p> TaggedBoundsCalculator.cs<pre><code>using DunGen;\nusing DunGen.TileBounds;\nusing UnityEngine;\n\n[SubclassDisplay(displayName: \"Tagged Bounds\")]//(1)!\npublic class TaggedBoundsCalculator : DefaultTileBoundsCalculator\n{\n    public string RequiredTag = \"BoundsObject\";//(2)!\n\n    protected override bool ShouldUseComponentBounds(Component comp)//(3)!\n    {\n        // If the base class says not to use it, we won't use it\n        if (!base.ShouldUseComponentBounds(comp))\n            return false;\n\n        // Only use the component if its GameObject has the required tag\n        return comp.gameObject.CompareTag(RequiredTag);\n    }\n}\n</code></pre> <ol> <li>The <code>SubclassDisplay</code> attribute can be used to show a custom display name in the inspector</li> <li>A Unity tag that a GameObject must have for its component bounds to be considered</li> <li>We override <code>ShouldUseComponentBounds()</code> to add custom filtering logic without re-implementing the full bounds calculation</li> </ol> <p>By understanding and utilizing these <code>Tile</code> component settings, you gain significantly more control over how your individual Tile prefabs behave and integrate into the final generated dungeon layout.</p>"},{"location":"core-concepts/weighting/","title":"Core Concepts: Weighting","text":""},{"location":"core-concepts/weighting/#what-is-weighting","title":"What is Weighting?","text":"<p>Throughout DunGen, you'll encounter settings related to Weight. Simply put, weight controls likelihood. When DunGen has to choose one item from a list (like picking which Tile to place next, or which Prop variant to keep), items with a higher weight are more likely to be chosen.</p> <p>Key Principle: Weights are relative.</p> <ul> <li>If Tile A has a weight of 1 and Tile B has a weight of 1, they have an equal chance of being chosen.</li> <li>If Tile A has a weight of 2 and Tile B has a weight of 1, Tile A is twice as likely to be chosen as Tile B.</li> <li>If Tile A has a weight of 0.5 and Tile B has a weight of 0.5, they still have an equal chance (same as 1 vs 1).</li> <li>If an item has a weight of 0, it will never be chosen under those conditions.</li> </ul> <p>You'll find weight settings primarily in:</p> <ul> <li>Tile Sets: Controlling the chance of each Tile prefab being selected.</li> <li>Prop Components (<code>Local Prop Set</code>, <code>Random Prefab</code>, <code>Global Prop</code>): Controlling the chance of props spawning or specific prefabs being chosen.</li> <li>Doorway Component (<code>Connectors</code>/<code>Blockers</code>): Controlling the chance of specific connector/blocker prefabs being chosen.</li> </ul>"},{"location":"core-concepts/weighting/#components-of-a-dungen-weight","title":"Components of a DunGen Weight","text":"<p>Weight used by a <code>Tile Set</code></p> <p>A full weight configuration in DunGen (like those found on Tiles within a Tile Set) has three main parts:</p> <ol> <li>Main Path Weight: The base likelihood of this item being chosen when DunGen is building the main path (the critical route from the start to the goal).</li> <li>Branch Path Weight: The base likelihood of this item being chosen when DunGen is building an optional branch path.<ul> <li>Why two base weights? This lets you make certain tiles or props common on the main path but rare in branches, or vice-versa. For example, maybe key quest rooms only appear on the main path (<code>Main Path Weight &gt; 0</code>, <code>Branch Path Weight = 0</code>).</li> </ul> </li> <li> <p>Depth Mode: Which depth information is used to modify the base weights using the <code>Depth Scale</code> curve below.</p> <ul> <li>None: No depth scaling applied. The <code>Main Path Weight</code> and <code>Branch Path Weight</code> stand as they are.</li> <li>Auto: Depth along the Main Path is used if the tile is on the main path, and depth along the current Branch Path is used if the tile is on a branch path.</li> <li>Main Path Depth: Uses the normalized (0-1) depth along the main path, even if the tile is on a branch.</li> <li>Branch Depth: Uses the normalized (0-1) depth along the current branch, or <code>0</code> if the tile in on the main path.</li> </ul> </li> <li> <p>Depth Scale (Curve): This is a powerful modifier that allows the item's likelihood to change based on how deep into the path it's being placed.</p> <ul> <li>How it works: The curve graph adjusts the effective weight.<ul> <li>The X-axis represents the normalized depth (0 = start of the path, 1 = end of the path).</li> <li>The Y-axis represents a multiplier (0 = zero chance, 1 = use the base weight exactly, 2 = double the base weight, etc.).</li> </ul> </li> <li>DunGen calculates the current depth (0-1), finds the corresponding multiplier value on the Y-axis of the curve, and multiplies the appropriate base weight (Main or Branch) by this value.</li> </ul> </li> </ol> <p>Example: </p> <p>Example depth scale curve. Starts low (Y=0) at the beginning (X=0) and ramps up high (Y=1) at the end (X=1)</p> <p>An item with this curve would never appear at the start of the dungeon path (base weight * 0.0) but would be increasingly likely (base weight * 1.0) to appear near the end.</p>"},{"location":"core-concepts/weighting/#putting-it-together","title":"Putting it Together","text":"<p>The final chance of an item being chosen at any given point is calculated roughly like this:</p> <p><code>Effective Weight = Base Weight (for current path type) * Depth Scale Multiplier (at current depth)</code></p> <p>DunGen then compares the <code>Effective Weight</code> of all possible choices at that moment to determine the probabilities.</p>"},{"location":"core-concepts/weighting/#practical-examples","title":"Practical Examples","text":"<ul> <li>Common Room: <code>Main Path Weight = 1</code>, <code>Branch Path Weight = 1</code>, <code>Depth Mode = None</code>. (Equal chance everywhere)</li> <li>Early Game Room: <code>Main Path Weight = 1</code>, <code>Branch Path Weight = 1</code>, <code>Depth Mode = Main Path Depth</code>, <code>Depth Scale = Starts high (Y=1), drops low (Y=0.1) near the end</code>. (Common early, rare late)</li> <li>Boss Room Ante-chamber: <code>Main Path Weight = 1</code>, <code>Branch Path Weight = 0</code>, <code>Depth Mode = Main Path Depth</code>, <code>Depth Scale = Starts very low (Y=0), sharply rises only near the end (X=0.9 to 1.0)</code>. (Only appears on the main path, right before the goal)</li> <li>Secret Room (Branches Only): <code>Main Path Weight = 0</code>, <code>Branch Path Weight = 1</code>, <code>Depth Mode = None</code>. (Only appears in branches, equal chance throughout branch length)</li> </ul> <p>By combining these three components, you can precisely control the frequency and placement context of your tiles and props within the generated dungeons.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to the Quick Start guide. Here, you'll learn how to create your first procedural dungeon layout using DunGen\u2014with minimal setup and fast results.</p> <p>We'll walk you through the core steps of DunGen's room-based system:</p> <ul> <li>Design Your Building Blocks: Create a simple room prefabs (Tile)</li> <li>Define Connection Points: Specify where doorways can appear</li> <li>Control the Structure: Build a basic <code>Dungeon Flow</code> graph to guide the generator</li> <li>Generate on Demand: Use the <code>Runtime Dungeon</code> component to bring it all together</li> </ul> <p>To keep things simple, we'll gloss over most settings for now and focus on the essentials. Once you've seen your first dungeon come to life, you'll be ready to dive deeper in later sections.</p> <p>Ready? Let's create your first tile \u2192</p>"},{"location":"getting-started/1-creating-tiles/","title":"Getting Started: Creating a Tile","text":""},{"location":"getting-started/1-creating-tiles/#room-geometry","title":"Room Geometry","text":"<p>First, we'll create a very simple tile. In DunGen, a Tile is a segment of your dungeon, usually a room or corridor, that the dungeon generator will piece together to create the final layout.</p> <p>Start by creating an empty GameObject and give it a descriptive name (e.g. \"Basic Room). This GameObject will act as the container for our room's geometry and doorways, and we'll later turn it into a prefab.</p> <p>Set up up the basic geometry of the room but leave gaps where you want doorways to be in the future. Not all of them will necessarily be used, so feel free to add more than you need.</p> <p>\u26a0\ufe0f Important: Doorways must be positioned on the edge of the Tile's Axis-Aligned Bounding Box (AABB). See the Limitations section for more details.</p> <p></p> <p>Basic room geometry with gaps for doors</p> <p>We have the shell of a room tile, now we need to tell DunGen how it should connect to other tiles. In the next step, we'll create doorways for our room.</p>"},{"location":"getting-started/2-doorways/","title":"Getting Started: Doorways","text":""},{"location":"getting-started/2-doorways/#creating-a-doorway","title":"Creating a Doorway","text":"<p>Now we need a way to tell DunGen where we want our doorways to be. To do this, we'll create another empty GameObject and call it \u201cDoorway\u201d. Be sure to parent it to your tile GameObject. Now we'll add a <code>Doorway</code> component to our new doorway: <code>Add Component &gt; DunGen &gt; Doorway</code></p> <p></p> <p>The doorway should be placed on the very edge of the tile with its local Z-axis (shown by the light blue line in the editor) pointing outwards.</p> <p>Working in 2D?</p> <p>Make sure the door is correctly oriented to match your up-direction. The green line should point upwards.</p> Can't see the doorway? <p>If the doorway outline isn't visible, check that Gizmos are enabled in the Scene view. Look for this button: . You may also need to expand the dropdown next to it and make sure the 'Doorway' checkbox is checked</p> <p>Don't worry if the outline doesn't match the shape or size of your doorway. For the purpose of this tutorial, all that matters is that the doorway is centred correctly.</p>"},{"location":"getting-started/2-doorways/#doorway-blockers","title":"Doorway Blockers","text":"<p>Right now, DunGen can connect Tiles using your doorway\u2014but unused doorways would leave visible gaps in the dungeon walls. To prevent this, we\u2019ll use Blockers to automatically fill in any unused doorways.</p> <p>A blocker can be anything that visually closes off a doorway: a wall, debris, furniture, or even a sealed door.</p> <p></p> <ol> <li>Create a new GameObject with a wall mesh (or whatever fits your aesthetic).</li> <li>Position it to block the doorway.</li> <li>Parent this blocker to the Doorway object.</li> <li>In the Doorway component, expand the Blockers section.</li> <li>Drag your blocker GameObject into the Scene Objects list.</li> </ol> <p>Now, when a doorway isn\u2019t used during generation, the blocker will be shown. If the doorway is connected to another room, DunGen will automatically hide the blocker.</p>"},{"location":"getting-started/2-doorways/#reusing-doorways","title":"Reusing Doorways","text":"<p>For easy reuse of our doorway, we can make it a prefab by dragging the GameObject into our project window. Now, any changes made will be reflected wherever we use our doorway prefab.</p> <p>Once that's done, you can easily duplicate and reuse it for each of the remaining door gaps in your room:</p> <ul> <li>Drag the prefab into the scene, or</li> <li>Select an instance and press Ctrl+D to duplicate it</li> </ul> <p>Place a doorway at each of the gaps you left earlier.</p>"},{"location":"getting-started/2-doorways/#recap","title":"Recap","text":"<p>At this stage, you should have:</p> <ul> <li> A simple room Tile</li> <li> A doorway placed at each entrance</li> <li> Each doorway containing a Blocker to fill in unused paths</li> </ul> <p>Here's what your setup should look like:</p> <p></p>"},{"location":"getting-started/3-dungeon-flow/","title":"Getting Started: Dungeon Flow Basics","text":"<p>Now that we've created a basic room Tile and added Doorways, it\u2019s time to give DunGen instructions on how to assemble those Tiles into a full dungeon.</p> <p>This is where the Dungeon Flow system comes in.</p>"},{"location":"getting-started/3-dungeon-flow/#marking-the-tile","title":"Marking the Tile","text":"<p>We need to add a <code>Tile</code> component to the root of our room (Add Component &gt; DunGen &gt; Tile). This component provides information about how DunGen should handle the tile. For now, the defaults are exactly what we need.</p> <p>Our tile GameObject now needs to be turned into a prefab. Drag the GameObject into a folder in the project window just like we did with the doorway.</p> <p>Before DunGen can use our room, we need to mark it as a Tile.</p> <ol> <li>Select the root of your room GameObject (e.g. \"BasicRoom\").</li> <li>Add the <code>Tile</code> component: <code>Add Component &gt; DunGen &gt; Tile</code></li> </ol> <p>The default settings will work just fine for now.</p> <p>Now turn your room into a prefab by dragging it into a folder in the Project window\u2014just like we did with the Doorway earlier.</p>"},{"location":"getting-started/3-dungeon-flow/#setting-up-assets","title":"Setting Up Assets","text":"<p>DunGen uses a few asset types to define how dungeons are generated:</p> <ul> <li> <p> Tile Set</p> <p>A collection of Tiles to choose from at random</p> </li> <li> <p> Archetype</p> <p>A type or \u201cbiome\u201d for a dungeon section</p> </li> <li> <p> Dungeon Flow</p> <p>The master graph that controls structure and progression</p> </li> </ul> <p>Let\u2019s create each of these now.</p>"},{"location":"getting-started/3-dungeon-flow/#tile-set","title":"Tile Set","text":"<p>Right-click in your Project window and choose: <code>Create &gt; DunGen &gt; Tile Set</code></p> <p>This asset holds the list of prefab Tiles DunGen can randomly choose from.</p> <p></p> <p>We just need to assign our tile prefab to the newly created tile set. With the Tile Set selected:</p> <ul> <li>Click Add New Tile, or</li> <li>Drag your Tile prefab directly onto the button</li> </ul>"},{"location":"getting-started/3-dungeon-flow/#archetype","title":"Archetype","text":"<p>An <code>Archetype</code> represents a segment of the dungeon path that allows us to have distinct sections. We could use these to create biomes (e.g. castle, graveyard), but we'll only need the one for this tutorial.</p> <p></p> <p>With the Archetype asset selected:</p> <ul> <li>Click Add New under the Tile Sets section, or</li> <li>Drag your Tile Set onto the button</li> </ul>"},{"location":"getting-started/3-dungeon-flow/#dungeon-flow","title":"Dungeon Flow","text":"<p>We have one final asset to create: the Dungeon Flow that ties everything together.</p> <p>Right-click in the project window once again and select: <code>Create &gt; DunGen &gt; Dungeon Flow</code></p> <p>This asset has a lot of options, but for now we're only concerned with the flow graph. With the dungeon flow asset selected, click on the Open Flow Editor button in the inspector and you will be greeted with the basic default graph containing just a Start and a Goal node, with a single line connecting them.</p> <p></p> <p>The default dungeon flow graph</p>"},{"location":"getting-started/3-dungeon-flow/#understanding-the-flow-graph","title":"Understanding the Flow Graph","text":""},{"location":"getting-started/3-dungeon-flow/#nodes","title":"Nodes","text":"<p>Nodes (such as Start and Goal) on the graph represent a single tile. Click on one of the nodes to edit it in the inspector. For now, we'll just add our only tile set to the list for both the Start and Goal nodes.</p> <p>Later, we might decide we want a specific tile at the beginning and/or end of the dungeon. This would be the place to do that. In future tutorials, we'll also look into adding additional nodes, allowing us to place specific rooms such as boss rooms that need to appear at certain points along the main path.</p>"},{"location":"getting-started/3-dungeon-flow/#lines","title":"Lines","text":"<p>Between the nodes is a single line and clicking on it reveals a simple list of archetypes in the inspector. As before, we'll assign our single archetype asset to this list. DunGen will make a path of random tiles between the two nodes connected by this line. In future tutorials, we'll split this line segment into multiple biomes.</p>"},{"location":"getting-started/3-dungeon-flow/#dungeon-length","title":"Dungeon Length","text":"<p>The overall length of the dungeon is not determined by the graph, and is instead set inside the <code>Dungeon Flow</code> asset as a range of values.</p> <p>Based on these numbers (and taking into account any nodes in the graph), DunGen will automatically calculate how long the line segments in the flow graph should be.</p>"},{"location":"getting-started/3-dungeon-flow/#recap","title":"Recap","text":"<p>You should now have three new assets in your project:</p> <ul> <li>A Tile Set with your room prefab</li> <li>An Archetype using that Tile Set</li> <li>A Dungeon Flow with a basic two-node graph</li> </ul> <p></p> <p>All the assets we've created</p> <p>Dungeon Validation</p> <p>To ensure we didn't make any mistakes along the way, we can validate the dungeon by selecting our <code>Dungeon Flow</code> asset and pressing the 'Validate Dungeon' button in the inspector. A message will appear in the console letting us know if any issues were detected.</p> <p>If you don't see the console window, go to <code>Window &gt; Panels &gt; Console</code> to open it.</p> <p>All that remains is to generate the dungeon layout, which we'll be doing in the next section \u2192</p>"},{"location":"getting-started/4-scene-setup/","title":"Getting Started: Scene Setup &amp; First Generation","text":"<p>Now that we have our dungeon flow set up, it's time to generate it.</p>"},{"location":"getting-started/4-scene-setup/#setting-up-the-generator","title":"Setting Up the Generator","text":"<p>Start with a clean scene or an empty GameObject in your existing one.</p> <ol> <li>Create a new <code>GameObject</code> and name it Dungeon Generator</li> <li>Add the <code>Runtime Dungeon</code> component: <code>Add Component &gt; DunGen &gt; Runtime Dungeon</code></li> </ol> <p></p> <p>In the Inspector:</p> <ul> <li>Assign your Dungeon Flow asset to the appropriate field</li> <li>Make sure Generate On Start is checked</li> </ul> <p>Now when you enter Play Mode, DunGen will automatically generate a dungeon based on your setup.</p> <p>\ud83c\udfa5 Tip: Switch to the Scene view during Play Mode to fly around and inspect the layout.  </p> <p></p> Generating in Code <p>We can generate a new dungeon in code as follows. Add this new component to any GameObject in your scene and be sure to assign your <code>Runtime Dungeon</code> to the field. Now, pressing R will generate a new random dungeon.</p> GenerateDungeonOnKeyPress.cs<pre><code>using DunGen;\nusing UnityEngine;\n\npublic class GenerateDungeonOnKeyPress : MonoBehaviour\n{\n    public RuntimeDungeon RuntimeDungeon;\n\n    void Update()\n    {\n        if(Input.GetKeyDown(KeyCode.R))\n        {\n            var generator = RuntimeDungeon.Generator;\n            generator.Generate();\n        }\n    }\n}\n</code></pre>"},{"location":"integrations/","title":"Integrations : Overview","text":"<p>DunGen is designed to work alongside other powerful tools from the Unity Asset Store to enhance your procedural generation workflow and improve runtime performance or usability.</p> <p>While pathfinding systems have their own dedicated section due to their complexity (Pathfinding Overview), this section covers other specific third-party asset integrations provided directly with DunGen. These integrations often utilize DunGen's Adapter system or specific hooks to automate setup or provide easier control.</p>"},{"location":"integrations/#included-integrations","title":"Included Integrations","text":"<p>Currently, DunGen offers built-in support for the following assets:</p> <ul> <li> <p>SECTR Portal Culling:     Automatically generate SECTR portals and sectors based on your DunGen room layout. This leverages SECTR's powerful visibility culling to significantly improve rendering performance in complex dungeons by hiding rooms that are not visible to the camera.</p> </li> <li> <p>PlayMaker Actions:     Provides custom PlayMaker actions allowing you to trigger DunGen generation and clearing processes directly from your PlayMaker Finite State Machines (FSMs), enabling visual scripting control over dungeon creation.</p> </li> </ul> <p>Please refer to the specific pages linked above for detailed setup instructions and usage information for each integration.</p> <p>If you are using an asset not listed here, you may still be able to integrate it with DunGen by leveraging its runtime API or by creating a Custom Adapter to run custom logic during DunGen's post-processing phase.</p>"},{"location":"integrations/playmaker/","title":"Integrations: PlayMaker","text":"<p>DunGen offers basic integration with Hutong Games' PlayMaker, a popular visual scripting tool for Unity. This allows you to control DunGen's dungeon generation process directly from your PlayMaker Finite State Machines (FSMs) without needing to write traditional C# code.</p> <p>Third-Party Asset Required</p> <p>PlayMaker is a separate asset available on the Unity Asset Store and must be purchased and imported into your project before setting up this integration.</p>"},{"location":"integrations/playmaker/#setup","title":"Setup","text":"<ol> <li>Ensure PlayMaker is successfully installed and operational in your project.</li> <li>Navigate to <code>Assets/DunGen/Integration/</code> in your Project view.</li> <li>Double-click the <code>PlayMaker.unitypackage</code> file to import its contents into your project.</li> </ol> <p>Once imported, you should find new DunGen-specific actions available in the PlayMaker Action Browser.</p>"},{"location":"integrations/playmaker/#available-playmaker-actions","title":"Available PlayMaker Actions","text":"<p>Currently, DunGen provides the following PlayMaker actions:</p>"},{"location":"integrations/playmaker/#generate","title":"Generate","text":"<ul> <li>Description: Generates a new dungeon layout using the settings configured on an existing <code>Runtime Dungeon</code> component in the scene.</li> <li>Usage:<ul> <li>You must have a GameObject in your scene with a <code>Runtime Dungeon</code> component already set up (with a Dungeon Flow asset assigned, etc.).</li> <li>In the PlayMaker action settings, specify the GameObject that contains this pre-configured <code>Runtime Dungeon</code> component.</li> <li>This action is useful when you prefer to manage your main generation settings directly on a component in the scene hierarchy.</li> </ul> </li> </ul>"},{"location":"integrations/playmaker/#generate-with-settings","title":"Generate with Settings","text":"<ul> <li>Description: Generates a new dungeon layout using settings specified directly within the PlayMaker action itself.</li> <li>Usage:<ul> <li>Configure the desired settings (like the <code>Dungeon Flow</code> asset, randomization seed, etc.) within the action's properties in the PlayMaker Editor.</li> <li>You do not necessarily need a pre-existing <code>Runtime Dungeon</code> component in the scene; if the specified target GameObject doesn't have one, this action can create one for you.</li> <li>Optional <code>Runtime Dungeon</code> Parameter: You can still specify a GameObject with an existing <code>Runtime Dungeon</code> component. If you do, the settings from the action will be used primarily, but any settings on the component not directly exposed in the PlayMaker action (like attached adapters, specific overrides, root object) will still be respected.</li> <li>This action is useful for more self-contained generation logic within your FSM, requiring less initial scene setup.</li> </ul> </li> </ul>"},{"location":"integrations/playmaker/#clear","title":"Clear","text":"<ul> <li>Description: Removes/destroys a previously generated dungeon layout associated with a specific <code>Runtime Dungeon</code> component.</li> <li>Usage:<ul> <li>Specify the GameObject that currently holds the <code>Runtime Dungeon</code> component whose generated dungeon you want to clear.</li> <li>This is typically used before generating a new dungeon layout to clean up the old one, or when transitioning away from the level.</li> </ul> </li> </ul>"},{"location":"integrations/playmaker/#basic-usage-example","title":"Basic Usage Example","text":"<p>You could create a simple FSM on a GameManager object:</p> <ol> <li>Start State: Waits for a trigger (e.g., \"Start Game\" event).</li> <li>Generate Dungeon State: Uses the <code>Generate</code> or <code>Generate with Settings</code> action to create the dungeon. Stores the GameObject containing the <code>Runtime Dungeon</code> component in a variable if needed for clearing later.</li> <li>Gameplay State: The game proceeds.</li> <li>(Optional) Clear Dungeon State: Triggered by an event (e.g., \"Exit Level\"). Uses the <code>Clear</code> action, referencing the stored GameObject variable, to remove the dungeon before loading a new scene.</li> </ol> <p>By using these actions, you can integrate DunGen's procedural capabilities into your projects using PlayMaker's intuitive visual scripting interface.</p>"},{"location":"integrations/sectr/","title":"Integrations: SECTR Portal Culling","text":"<p>DunGen provides built-in integration with SECTR, a powerful portal-based visibility culling system available on the Unity Asset Store. This integration automatically generates SECTR Sectors and Portals based on your DunGen Tile layout, helping to significantly improve rendering performance by culling rooms (Sectors) that are not visible through doorways (Portals).</p> <p>Third-Party Asset Required</p> <p>SECTR is a separate asset available on the Unity Asset Store and must be purchased and imported into your project before setting up this integration.</p>"},{"location":"integrations/sectr/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install SECTR World Straming into your Unity project from the Asset Store.</li> <li>Ensure the DunGen integration scripts are available. If you haven't already, navigate to <code>Assets/DunGen/Integration/</code> in your Project view and double-click the <code>SECTR_VIS.unitypackage</code> file to extract its contents.</li> </ol>"},{"location":"integrations/sectr/#setup","title":"Setup","text":"<p>Setting up the integration is straightforward:</p> <ol> <li>Locate the GameObject in your scene that has the <code>Runtime Dungeon</code> component attached.</li> <li>Add the <code>SECTR VIS Portal Culling Adapter</code> component to this same GameObject (<code>Add Component &gt; DunGen &gt; Culling &gt; SECTR VIS Portal Culling Adapter</code>).</li> <li>Select your main Player Camera GameObject.</li> <li>Add the <code>SECTR Culling Camera</code> component to your Player Camera (<code>Add Component &gt; Procedural Worlds &gt; SECTR &gt; Vis &gt; SECTR Culling Camera</code>).</li> </ol> <p>That's it! The DunGen adapter will now run automatically during the post-processing phase after dungeon generation.</p>"},{"location":"integrations/sectr/#adapter-component-settings","title":"Adapter Component Settings","text":"<p>The <code>SECTR VIS Portal Culling Adapter</code> has a few settings:</p> <ul> <li><code>Priority</code>: Determines the execution order if multiple DunGen adapters are present. Usually, the default (-1, often running after pathfinding) is suitable.</li> <li><code>Directional Shadow Caster</code>: (Optional) Assign your main directional light here if you want SECTR to manage shadow culling based on Sector visibility.</li> <li><code>Extra Bounds</code>: Allows you to add padding to the automatically calculated Sector bounds.</li> <li><code>Cull Each Child</code>: Determines SECTR should cull child Sectors individually or if culling is done based solely on the single Sector for the Tile.</li> </ul> <p>SECTR Documentation</p> <p>For detailed explanations of these SECTR-specific settings (<code>Directional Shadow Caster</code>, <code>Extra Bounds</code>, <code>Cull Each Child</code>), please refer to the official SECTR documentation.</p>"},{"location":"integrations/sectr/#runtime-behaviour","title":"Runtime Behaviour","text":"<p>Once set up:</p> <ol> <li>DunGen generates the dungeon layout.</li> <li>During post-processing, the <code>SECTR VIS Portal Culling Adapter</code> runs.</li> <li>The adapter automatically creates:<ul> <li>A <code>SECTR Sector</code> component for each <code>Tile</code> instance in the dungeon.</li> <li>A <code>SECTR Portal</code> component spanning each connected <code>Doorway</code> between Tiles.</li> </ul> </li> <li>The <code>SECTR Culling Camera</code> on your camera then uses this Sector and Portal information to perform visibility culling each frame.</li> </ol>"},{"location":"integrations/sectr/#handling-doors","title":"Handling Doors","text":"<p>To allow doors to dynamically open and close, affecting visibility:</p> <ol> <li>Ensure your door prefabs (used as Connectors or via the Lock &amp; Key system) have a script attached that includes a <code>Door</code> component.</li> <li>This script must correctly set the <code>Door</code> component's <code>IsOpen</code> property to <code>true</code> when the door is open and <code>false</code> when it's closed.</li> </ol> <p>The DunGen integration automatically configures the generated <code>SECTR Portal</code> components to check the <code>IsOpen</code> status of the associated <code>Door</code> component. When <code>IsOpen</code> is <code>false</code>, the portal will be closed, and SECTR VIS will cull the Sector behind it. When <code>true</code>, the portal opens, allowing SECTR VIS to potentially render the Sector beyond.</p> <p>Using the SECTR VIS integration is an effective way to boost rendering performance in your DunGen-powered levels, especially in complex interior environments.</p>"},{"location":"optimization/","title":"Optimization: Overview","text":"<p>Procedural dungeon generation offers incredible flexibility and replayability, but generating complex layouts at runtime can sometimes impact performance. DunGen provides several built-in features and supports integrations to help you manage the performance cost and ensure a smooth player experience.</p> <p>This section covers key techniques for optimizing your DunGen-powered levels:</p> <ul> <li> <p>Built-in Culling:     Learn about DunGen's built-in culling system used to reduce the number of rooms that are rendered. Understand each culling strategy (<code>Adjacency Culling</code>, <code>Frustum Culling</code>, and <code>Portal Culling</code>) and their pros and cons.</p> </li> <li> <p>Tile Pooling:     Discover how to use object pooling for your Tile prefabs. This can significantly reduce generation times caused by frequent instantiation and destruction of complex Tile GameObjects.</p> </li> </ul> <p>Choosing the right optimization strategies depends on your game's specific requirements, target platform, and the complexity of your generated dungeons. Review the pages in this section to determine which techniques will provide the most benefit for your project.</p>"},{"location":"optimization/culling/","title":"Optimization: Culling","text":"<p>DunGen includes a built-in visibility culling system to minimize how many rooms (tiles) are rendered at once. To use it, add the <code>Culling Camera</code> component to your player camera (<code>Add Component &gt; DunGen &gt; Culling &gt; Culling Camera</code>).</p>"},{"location":"optimization/culling/#culling-strategies","title":"Culling Strategies","text":"<p>Several strategies are supported, each with different performance trade-offs. Select one using the <code>Strategy</code> dropdown on the <code>Culling Camera</code> component.</p>"},{"location":"optimization/culling/#adjacency-culling","title":"Adjacency Culling","text":"<p>Tile depth = 2. Cyan area is the player's camera frustum.</p> <p>Adjacency culling shows only the room the player is in plus nearby rooms (outward recursively up to a configured depth). Everything else is hidden.</p> <p>It offers consistently high performance and very stable CPU cost, but at low depths the player could notice rooms popping in through open doorways. Auto-closing doors help hide this.</p> <ul> <li>Settings:<ul> <li><code>Character</code>: Used as the centre of culling (usually the player).</li> <li><code>Adjacent Tile Depth</code>:<ul> <li><code>0</code>: Only the current tile.</li> <li><code>1</code>: Current tile + directly connected neighbours.</li> <li><code>2+</code>: Expands breadth-first per step.</li> <li>Higher values reduce culling effectiveness.</li> </ul> </li> <li><code>Cull Behind Closed Doors</code>:<ul> <li>Stops traversal through doorways whose <code>Door.IsOpen == false</code>.</li> <li>Requires your door prefabs correctly update the <code>Door</code> component. See Doors.</li> </ul> </li> </ul> </li> </ul> <p>When to use it?</p> <p>Use Adjacency Culling when:</p> <ul> <li>The camera is inside the dungeon (first-person, over-the-shoulder, tight third-person).</li> <li>You have (auto-)closing doors or narrow sightlines.</li> <li>You need highly predictable performance (e.g. VR, low-end hardware).</li> </ul> <p>Avoid very large depths; if you need higher depths, consider Portal Culling instead.</p>"},{"location":"optimization/culling/#frustum-culling","title":"Frustum Culling","text":"<p>Cyan area is the player's camera frustum.</p> <p>Frustum culling mirrors Unity's built\u2011in frustum culling but operates at the tile level: an entire tile is culled or shown based on the bounds of the tile instead of testing each renderer individually. It typically hides fewer tiles than the other strategies.</p> <p>When to use it?</p> <p>Choose Frustum Culling when:</p> <ul> <li>The camera is outside or significantly above the dungeon (top-down / isometric).</li> <li>Door-based occlusion is ineffective (mostly open layouts).</li> </ul> <p>It is less aggressive, so gains may be modest.</p>"},{"location":"optimization/culling/#portal-culling","title":"Portal Culling","text":"<p>Cyan area is the player's camera frustum. Magenta areas are projected frustums through visible portals.</p> <p>Portal culling projects the camera frustum through visible doorways (treating them as portals). A room is visible if it is directly seen or seen through a chain of doorways. The number of visible rooms changes dynamically with player orientation: looking at a blank wall may show only one room; looking down a long corridor may reveal many.</p> <p>When to use it?</p> <p>Use Portal Culling when:</p> <ul> <li>The camera resides inside the dungeon tiles (first-person or tight third-person).</li> <li>You have long corridors / aligned doorways that create deep sightlines and you want them rendered only when actually looked down.</li> <li>Pop-in must be minimized while still culling aggressively when the player faces occluding geometry.</li> <li>Doors may stay open and adjacency depth would otherwise need to be large. Performance Notes:</li> <li>CPU cost varies with how many portals are in view and recursion depth (worst case: looking into a hub with many doorways, or a long corridor).</li> <li>Ensure doorway geometry (portal rectangles) closely matches openings; oversized bounds reduce effectiveness.</li> </ul> <p>Avoid Portal Culling if:</p> <ul> <li>The camera is top-down/outside the dungeon.</li> <li>Most rooms are fully open (few occluding walls) \u2014 Frustum or Adjacency may then be simpler.</li> </ul>"},{"location":"optimization/culling/#choosing-the-right-strategy","title":"Choosing the Right Strategy","text":"<p>Use this section as a quick decision aid:</p> <ol> <li>Where is the camera?<ul> <li>Inside / immersive view (FPS / TPS) \u2192 Prefer Adjacency or Portal.</li> <li>Above / detached (top-down / isometric) \u2192 Frustum (others may under\u2011cull or malfunction).</li> </ul> </li> <li>Are doors common and usually closed?<ul> <li>Yes \u2192 Adjacency (low depth) is typically best.</li> </ul> </li> <li>Are there long, aligned sightlines you only want when actually viewed?<ul> <li>Yes \u2192 Portal Culling.</li> </ul> </li> <li>Do you need extremely predictable frame times (e.g. VR)?<ul> <li>Yes \u2192 Adjacency (fixed traversal cost).</li> </ul> </li> <li>Are memory / draw call limits tight but CPU budget small?<ul> <li>Adjacency (cheap CPU, strongest average cull).</li> </ul> </li> </ol> <p>Rule of Thumb</p> <ul> <li>Start with Adjacency (depth 1\u20132). If players notice voids where rooms should be, try Portal Culling.</li> <li>If your camera ever leaves interior space or has a bird's-eye view, switch to Frustum Culling.</li> <li>Profile worst-case scenes (open hubs) for Portal Culling to ensure recursion cost is acceptable.</li> </ul> <p>Comparative Summary</p> <ul> <li>Adjacency: Deterministic cost, strongest average culling, possible visible pop-in without door occlusion.</li> <li>Portal: Adaptive, best visual fidelity vs overdraw, variable CPU cost.</li> <li>Frustum: Simplest, lowest variability, weakest culling aggressiveness.</li> </ul>"},{"location":"optimization/culling/#global-vs-per-camera-culling","title":"Global vs Per-Camera Culling","text":"<p>By default, the <code>Culling Camera</code> uses global culling (<code>Per Camera Culling</code> unchecked), where the rendering state of each room is set once from the point of view of the camera (there should be only one culling camera if using global culling). This is the best option for performance, but may not be feasible if you have multiple cameras rendering the scene.</p> <p>When <code>Per Camera Culling</code> is checked, DunGen will instead toggle the visibilities of each visible room one per-frame, per-camera. This allows for multiple cameras to render the scene, but at the cost of performance.</p> <p>As a rule of thumb, keep <code>Per Camera Culling</code> unchecked unless you need it.</p>"},{"location":"optimization/culling/#alternatives-integration","title":"Alternatives &amp; Integration","text":"<p>If the built-in culling doesn't meet your needs, consider:</p> <ul> <li>Third-Party Assets: Tools like SECTR (integrates directly with DunGen) provide advanced portal / sector systems.</li> <li>Custom Integration: Derive from <code>DunGen.Adapters.CullingAdapter</code> and implement <code>PrepareForCulling</code>. DunGen invokes this during post-processing, letting you feed visibility data into another system.</li> </ul>"},{"location":"optimization/tile-pooling/","title":"Optimization: Tile Pooling","text":"<p>Important Consideration</p> <p>Enabling Tile Pooling requires careful management of object states within your Tiles. Objects might persist in an altered state (e.g., an opened chest) when a Tile is reused. See the Managing State section for more details.</p>"},{"location":"optimization/tile-pooling/#what-is-tile-pooling","title":"What is Tile Pooling?","text":"<p>By default, when a Tile is no longer needed, it is simply destroyed. By contrast, with Tile Pooling enabled, Tiles are instead disabled and returned to the pool when they are no longer needed. This allows them to be reused later, avoiding costly instantiation of new Tile GameObjects.</p> <p>As you can see from the charts below, enabling Tile Pooling significantly speeds up dungeon generation, reducing time spent on instantiating tiles by as much as 70%.</p> <p></p> <p></p> <p>Note</p> <p>Tile Pooling will not improve the generation speed of the first dungeon you generate, as there will be no Tiles in the pool at that point. See the Pre-Warming the Pool section below to see how pooling can be used to improve first-run dungeons as well.</p>"},{"location":"optimization/tile-pooling/#enabling-tile-pooling","title":"Enabling Tile Pooling","text":"<p>Tile Pooling can be enabled from the project settings (<code>Edit &gt; Project Settings... &gt; DunGen</code>). Under the 'Optimization' section, check the <code>Enable Tile Pooling</code> checkbox. That's it! DunGen will now reuse old tiles.</p>"},{"location":"optimization/tile-pooling/#pre-warming-the-pool","title":"Pre-Warming the Pool","text":"<p>By default, Tile Pooling will only improve performance in subsequent dungeon generations, as there are no tiles yet in the pool for the initial generation. We can solve this by pre-warming the pool with some tiles that we will instantiate in the editor and save alongside the scene. We do this with the <code>Tile Pool Preloader</code> component.</p>"},{"location":"optimization/tile-pooling/#creating-the-tile-pool-preloader","title":"Creating the <code>Tile Pool Preloader</code>","text":"<ol> <li>Create a new GameObject in your scene</li> <li>Add the <code>Tile Pool Preloader</code> component (<code>Add Component &gt; DunGen &gt; Pooling &gt; Tile Pool Pre-loader</code>)</li> </ol>"},{"location":"optimization/tile-pooling/#using-the-pre-loader","title":"Using the Pre-loader","text":"<p>The main area of interest in the inspector is the 'Tile Pool Entries' list. New entries can be added to the list by simply dragging DunGen assets (<code>Tile</code>, <code>TileSet</code>, <code>Archetype</code>, or <code>DungeonFlow</code>) from your project view onto the list. All Tiles in the asset will be extracted and put into the list.</p> <p>Tile Pool Entries</p> <p>Each entry in the list has two components:</p> <ul> <li>Tile: The Tile prefab we want to add to the pool</li> <li>Count: The number of instances we want to seed the pool with</li> </ul> <p>Utilities</p> <p>For ease of use, there is a 'List Controls' foldout at the top of the inspector which includes some tools for speeding up the process.</p> <ul> <li>Clear List (Button): Clears all entries from the list.</li> <li>Set All Counts: Type in a number and press the Apply button and the instance count for all tiles in the list will be set all at once.</li> </ul> <p>Creating Instances</p> <p>Clicking the Refresh Instances button will prompt you to confirm that you would like to instantiate the specified number of tiles, once you accept, it will update the Tile instances spawned inside your scene to match the chosen instance counts. Pressing the Clear Instances button will destroy all spawned Tile instances.</p> <p>How Many Tiles Should I Pre-load?</p> <p>The ideal number depends on your project's specific needs. A good starting point is to estimate the maximum number of each Tile type you expect to see in your largest possible dungeon configuration. Pre-loading enough to cover this means you might avoid runtime instantiation altogether, but will increase initial scene loading times and memory usage. Insufficient pre-loading means you still gain benefits but might occasionally instantiate new tiles at runtime if the pool runs dry. Experimentation is key to finding the right balance for your target platform and dungeon complexity.</p> <p>Now, when DunGen generates a new DunGen on this scene, it will automatically pull in all of the Tile instances created by the pre-loader and put them into the pool, ready for use immediately.</p>"},{"location":"optimization/tile-pooling/#managing-state","title":"Managing State","text":"<p>There is a major downside to enabling Tile Pooling to consider. Now that Tiles are reused, they will retain any changes made to them by the player. For example, if the player opens a treasure chest in the boss room, the next time that boss room is needed, the chest will still be open from before.</p> <p>This means that any stateful object will either need to be:</p> <ul> <li>Spawned outside of your Tiles (ideally attached to the Dungeon root so it will be automatically cleaned up).</li> <li>Have their state reset when the Tile it's in is returned to the pool.</li> </ul> <p>You can receive a callback on any object inside a Tile when its containing Tile is taken from the pool (spawned) or returned to the pool (de-spawned) by implementing the <code>ITileSpawnEventReceiver</code> interface. Implement the following functions:</p> <pre><code>// Called when the Tile instance containing this component is retrieved from the pool and placed in the dungeon\nvoid OnTileSpawned(Tile tile);\n\n// Called just before the Tile instance containing this component is disabled and returned to the pool\nvoid OnTileDespawned(Tile tile);\n</code></pre> <p>Use <code>OnTileSpawned</code> or <code>OnTileDespawned</code> to reset the state of your interactive objects (e.g., close chests, reset enemy spawners, restore breakable objects) before the Tile is potentially reused.</p> <p>Tile Pooling can be a powerful option for reducing dungeon generation times, but it requires a more thoughtful approach to designing Tiles with interactive elements.</p>"},{"location":"pathfinding/","title":"Pathfinding: Overview","text":"<p>Once your dungeon layout is generated by DunGen, a crucial next step for many games is enabling Artificial Intelligence (AI) agents, such as enemies or NPCs, to navigate the space effectively. This requires a pathfinding system to analyze the generated geometry and create navigation data (like a NavMesh or pathfinding graph).</p> <p>DunGen itself focuses solely on generating the dungeon's layout and structure; it does not include its own pathfinding logic. However, since the dungeon is created dynamically at runtime, static pathfinding data baked in the editor won't work. The navigation data needs to be generated or updated after the DunGen layout is complete.</p> <p>DunGen addresses this by providing Integration Adapters. These are components you add alongside your <code>Runtime Dungeon</code> component. They hook into DunGen's post-processing phase and automatically trigger the necessary actions in your chosen pathfinding system (like baking a NavMesh or scanning a graph) once the dungeon geometry is finalized.</p>"},{"location":"pathfinding/#supported-pathfinding-systems","title":"Supported Pathfinding Systems","text":"<p>DunGen comes with built-in adapters for several popular pathfinding solutions:</p> <ul> <li>Unity NavMesh Components: Integration with Unity's modern, component-based NavMesh system (requires separate package installation from Unity). Supports runtime baking and linking across tiles. Includes a 2D variant.</li> <li>A* Pathfinding Project Pro: Support for the Recast NavMesh in Aron Granberg's powerful third-party pathfinding asset. Enables runtime graph scanning after generation.</li> </ul>"},{"location":"pathfinding/#custom-integrations","title":"Custom Integrations","text":"<p>If you are using a different pathfinding system not listed above, you can create your own integration:</p> <ul> <li>Custom Adapters: Learn how to write your own adapter script by inheriting from DunGen's <code>BaseAdapter</code> class. This allows you to trigger any custom logic needed by your pathfinding solution during DunGen's post-processing phase.</li> </ul>"},{"location":"pathfinding/#handling-doors","title":"Handling Doors","text":"<p>A common requirement is handling doors that open and close, dynamically changing path availability. The specific integration pages detail how each adapter typically handles doors, often relying on DunGen's built-in Door component to toggle walkability in the pathfinding data.</p> <p>Please navigate to the page corresponding to the pathfinding system you are using in your project for specific setup instructions and details.</p>"},{"location":"pathfinding/astar-pathfinding/","title":"Pathfinding: A* Pathfinding Project Pro","text":"<p>DunGen provides integration for Aron Granberg's powerful A* Pathfinding Project Pro asset, allowing you to automatically generate or update pathfinding graphs at runtime after your dungeon layout is created.</p> <p>Third-Party Asset Required</p> <p>A* Pathfinding Project Pro is a separate asset available on the Unity Asset Store and must be purchased and imported into your project.</p>"},{"location":"pathfinding/astar-pathfinding/#prerequisites","title":"Prerequisites","text":"<p>Install A* Pathfinding Project Pro into your Unity project.</p>"},{"location":"pathfinding/astar-pathfinding/#setup","title":"Setup","text":"<ol> <li>Ensure you have an Astar Path component configured somewhere in your scene (typically on a dedicated manager GameObject). You need to have at least one Recast graph type set up. Configure the basic settings of your graph (like agent size, collision masks, etc.) as needed before runtime.</li> <li>Locate the GameObject in your scene that has the <code>Runtime Dungeon</code> component attached.</li> <li>Add the <code>A* Pathfinding NavMesh Generator</code> component to this same GameObject (<code>Add Component &gt; DunGen &gt; NavMesh &gt; A* Pathfinding NavMesh Generator</code>).</li> </ol> <p>This adapter component will automatically run during DunGen's post-processing phase after the dungeon geometry is finalized.</p>"},{"location":"pathfinding/astar-pathfinding/#adapter-component-settings","title":"Adapter Component Settings","text":"<p>The specific settings on the <code>A* Pathfinding NavMesh Generator</code> component might vary slightly depending on DunGen and A*PP versions, but they typically include:</p> <ul> <li><code>Priority</code>: Determines the order in which multiple DunGen adapters are run. Lower numbers run first. The default is usually sufficient.</li> <li>Settings for Door Handling: Specific fields related to tags for open and closed doors (see Handling Doors below).</li> </ul>"},{"location":"pathfinding/astar-pathfinding/#handling-doors","title":"Handling Doors","text":"<p>A common requirement is making doors block pathfinding when closed and allow it when open. The recommended approach with A*PP and DunGen relies on Tags:</p> <ol> <li>Create a Layer: In Unity's Tag &amp; Layer Manager (<code>Edit &gt; Project Settings &gt; Tags and Layers</code>), create a new physics layer specifically for your doors (e.g., \"Doors\").</li> <li>Configure A* Graph: In your Astar Path component's graph settings (e.g., for your Recast Graph), find the collision testing or masking options. Ensure that the \"Doors\" layer you created is excluded from the mask used for building the graph. This prevents the graph from being built under the physical space occupied by closed doors.</li> <li>Set Door Prefab Layer: Make sure all door prefabs used by DunGen (Connectors, Locked Doors, etc.) are assigned to the \"Doors\" layer you created.</li> <li>Configure Adapter Tags: In the <code>A* Pathfinding NavMesh Generator</code> component settings, assign the \"Open Door\" and \"Closed Door\" tags you created in A*PP to the corresponding fields in the adapter.</li> <li>Configure AI Agents: In your A* agent scripts (like <code>AIPath</code>), configure the \"Traversable Tags\" to include your standard walkable tag(s) and the \"Open Door\" tag, but exclude the \"Closed Door\" tag.</li> </ol> <p>This setup ensures that the initial scan ignores closed doors, the adapter applies initial tags correctly, and door objects dynamically update path availability by changing tags, which your AI agents respect.</p> <p>By using the <code>A* Pathfinding NavMesh Generator</code> adapter and correctly configuring layers and tags, you can effectively integrate A* Pathfinding Project Pro with your DunGen-powered procedural dungeons.</p>"},{"location":"pathfinding/custom-adapters/","title":"Pathfinding: Custom Adapters","text":"<p>While DunGen provides built-in integration adapters for popular pathfinding solutions like Unity NavMesh Components and A* Pathfinding Project Pro, you might be using a different system. DunGen offers a flexible way to integrate any third-party system (including custom pathfinding solutions) by creating your own Custom Adapter.</p>"},{"location":"pathfinding/custom-adapters/#whats-an-adapter","title":"What's an Adapter?","text":"<p>DunGen Adapters are C# script components that hook into the dungeon generation lifecycle, specifically during the post-processing phase. This phase occurs after the main dungeon layout (Tiles and connections) has been generated and placed in the scene.</p> <p>By creating a script that inherits from DunGen's <code>NavMeshAdapter</code> class, you can execute your custom logic at the right time, allowing you to trigger actions in your chosen pathfinding system, such as:</p> <ul> <li>Scanning or baking navigation data based on the generated geometry.</li> <li>Placing specific pathfinding-related objects or markers.</li> <li>Updating pathfinding graphs based on door states or other dynamic elements.</li> </ul>"},{"location":"pathfinding/custom-adapters/#the-navmeshadapter-class","title":"The <code>NavMeshAdapter</code> Class","text":"<p>To create a custom adapter, your script must inherit from <code>DunGen.Adapters.NavMeshAdapter</code>.</p> <pre><code>using UnityEngine;\nusing DunGen;\nusing DunGen.Adapters;\n\npublic class MyCustomPathfindingAdapter : NavMeshAdapter\n{\n    // Your custom settings can go here (exposed in the Inspector)\n    // [SerializeField] private float scanResolution = 0.5f;\n\n    // You MUST override the abstract Generate method\n    public override void Generate(Dungeon dungeon)\n    {\n        Debug.Log(\"My Custom Pathfinding Adapter is running!\");\n\n        // --- Add your custom pathfinding logic here ---\n        // Example: Trigger your pathfinding system's API\n        // MyPathfindingSystem.Instance.ScanNewArea(dungeon.AllTiles);\n    }\n}\n</code></pre> <p>Key points about <code>NavMeshAdapter</code>:</p> <ul> <li>It inherits from <code>MonoBehaviour</code>, so it's a standard Unity component.</li> <li>It includes a virtual <code>Priority</code> property (defaulting to 0) which you can override if you need to control the execution order relative to other DunGen adapters (lower priority runs first).</li> <li>It defines the abstract <code>Generate</code> method, which you must implement.</li> </ul>"},{"location":"pathfinding/custom-adapters/#the-generate-method","title":"The <code>Generate</code> Method","text":"<p>This is the core of your custom adapter. DunGen automatically calls this method during its post-processing phase.</p> <ul> <li>Parameter: It receives a <code>Dungeon</code> object as input.</li> <li><code>Dungeon</code> Object: This object contains comprehensive information about the just-generated dungeon layout, including:<ul> <li><code>dungeon.AllTiles</code>: A collection of all <code>Tile</code> instances placed in the scene.</li> <li><code>dungeon.MainPathTiles</code>: Tiles belonging to the main path.</li> <li><code>dungeon.BranchPathTiles</code>: Tiles belonging to branch paths.</li> <li><code>dungeon.Connections</code>: A collection of <code>DoorwayConnection</code> objects detailing which doorways were connected.</li> <li><code>dungeon.Root</code>: The root GameObject containing the generated dungeon.</li> <li>... and other useful properties about the layout.</li> </ul> </li> <li>Timing: This method executes after all tiles, props (via <code>Global Props</code>), doors (via <code>Doorway</code> Connectors), and Lock &amp; Key elements have been placed.</li> </ul>"},{"location":"pathfinding/custom-adapters/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Create Script: Create a new C# script in your Unity project (e.g., <code>MyCustomPathfindingAdapter.cs</code>).</li> <li>Inherit &amp; Implement: Make the class inherit from <code>DunGen.Adapters.NavMeshAdapter</code> and implement the required <code>public override void Generate(Dungeon dungeon)</code> method. Include the necessary <code>using</code> statements.</li> <li>Add Logic: Inside the <code>Generate</code> method, write the code needed to interact with your specific pathfinding system's API. Use the provided <code>dungeon</code> object to get information about the layout (e.g., bounds of tiles, doorway connection points).</li> <li>Attach Component: Add your custom adapter script as a component to the same GameObject in your scene that has the <code>Runtime Dungeon</code> component. DunGen automatically detects and runs all <code>BaseAdapter</code> components attached to this GameObject.</li> <li>(Optional) Set Priority: If the execution order matters relative to other adapters (like built-in ones or other custom ones), override the <code>Priority</code> property in your script.</li> </ol>"},{"location":"pathfinding/custom-adapters/#considerations","title":"Considerations","text":"<ul> <li>Performance: Be mindful that complex pathfinding calculations performed synchronously within the <code>Generate</code> method can cause a noticeable hitch or delay when the dungeon generation completes. Consider if your pathfinding system offers asynchronous updating options that you can trigger from the adapter.</li> <li>Dependencies: Ensure any necessary manager objects or setup for your pathfinding system are already present and initialized in the scene before DunGen generation starts.</li> <li>Error Handling: Implement robust error checking (e.g., checking for nulls, using try-catch blocks) within your <code>Generate</code> method to prevent issues in your pathfinding logic from breaking the entire generation process.</li> </ul> <p>By creating a custom adapter, you can seamlessly integrate virtually any pathfinding system with DunGen's powerful procedural generation capabilities.</p>"},{"location":"pathfinding/unity-navmesh/","title":"Pathfinding: Unity NavMesh Components","text":"<p>DunGen offers built-in integration with Unity's modern, component-based NavMesh Components system (package <code>com.unity.ai.navigation</code>). This allows you to automatically generate or utilize NavMesh data for your procedurally generated dungeons at runtime, enabling AI navigation.</p> <p>Separate Package Required</p> <p>Unity's NavMesh Components system is not included with the Unity Editor by default (as of writing). You must install it via the Unity Package Manager (<code>Window &gt; Package Management &gt; Package Manager</code>). Search for <code>AI Navigation</code> or add it by name: <code>com.unity.ai.navigation</code>.</p>"},{"location":"pathfinding/unity-navmesh/#prerequisites","title":"Prerequisites","text":"<p>Install the NavMesh Components package (<code>com.unity.ai.navigation</code>) into your Unity project using the Package Manager.</p>"},{"location":"pathfinding/unity-navmesh/#setup","title":"Setup","text":"<ol> <li>Locate the GameObject in your scene that has the <code>Runtime Dungeon</code> component attached.</li> <li>Add the <code>Unity Nav Mesh Adapter</code> component to this same GameObject (<code>Add Component &gt; DunGen &gt; NavMesh &gt; Unity NavMesh Adapter</code>).</li> </ol> <p>This adapter will automatically run during DunGen's post-processing phase after the dungeon layout is generated.</p>"},{"location":"pathfinding/unity-navmesh/#adapter-component-settings","title":"Adapter Component Settings","text":"<p>The <code>Unity Nav Mesh Adapter</code> component has several settings to control how NavMesh generation occurs:</p> <ul> <li> <p><code>Priority</code>: Determines the order in which multiple DunGen adapters are run. Lower numbers run first. Usually, the default value is fine unless you have complex inter-adapter dependencies.</p> </li> <li> <p><code>Runtime Bake Mode</code>: This crucial setting defines how the NavMesh data is generated or handled at runtime:</p> <ul> <li><code>Pre-Baked Only</code>:<ul> <li>Requires: You must add a <code>NavMeshSurface</code> component to each of your Tile prefabs and bake them individually in the Editor beforehand.</li> <li>Functionality: DunGen will not generate any new NavMesh data at runtime. It assumes the necessary data already exists on the tiles. This is the most performant runtime option as no baking occurs. Use <code>Link Rooms</code> (see below) to connect these separate surfaces.</li> </ul> </li> <li><code>Add If No Surface Exists</code>:<ul> <li>Functionality: If a placed Tile prefab doesn't already have a <code>NavMeshSurface</code>, the adapter will add one and bake it at runtime. Tiles that do have a pre-baked surface are left untouched.</li> <li>Use Case: Useful if you want to pre-bake complex tiles but have simpler tiles baked dynamically.</li> </ul> </li> <li><code>Always Re-bake</code>:<ul> <li>Functionality: Ignores any existing <code>NavMeshSurface</code> components on Tile prefabs. Adds a new <code>NavMeshSurface</code> to every placed Tile instance that doesn't already have, and bakes every Tile's surface at runtime.</li> </ul> </li> <li><code>Full Dungeon Bake</code>:<ul> <li>Functionality: Ignores any NavMesh data on individual tiles. After the entire dungeon layout is generated, it adds a single, large <code>NavMeshSurface</code> component encompassing the whole dungeon and performs one bake operation.</li> <li>Pros: Can result in a more seamless NavMesh, especially for complex layouts or large open areas within the dungeon. Simpler setup as you don't need surfaces on prefabs.</li> <li>Cons: Can be significantly slower than other modes, especially for large dungeons, as the entire bake happens at once.</li> </ul> </li> </ul> </li> <li> <p><code>Link Rooms</code>:</p> <ul> <li>Functionality: If checked, DunGen will automatically place <code>NavMeshLink</code> components across connected doorways between adjacent Tiles.</li> <li>Purpose: This is essential when using pre-baked NavMeshes (<code>Pre-Baked Only</code> mode) or tile-by-tile baking (<code>Add If No Surface Exists</code>, <code>Always Re-bake</code>) as it allows AI agents to pathfind between the separate NavMesh surfaces of each tile.</li> <li>Ignored: This setting has no effect in <code>Full Dungeon Bake</code> mode, as there's only one continuous surface.</li> </ul> </li> <li> <p><code>Auto-Calculate Link Points</code>:</p> <ul> <li>If checked, DunGen will attempt to automatically calculate the start and end points of the link between rooms. If unchecked, the start and end points of the link will be a fixed distance from the doorway (see below).</li> </ul> </li> <li> <p><code>Distance from Doorway</code>:</p> <ul> <li>Controls how far from the center of the doorway (on either side) the generated <code>NavMeshLink</code> starts and ends. Adjust this based on your agent size and doorway geometry. Only relevant if <code>Link Rooms</code> is checked.</li> </ul> </li> <li> <p><code>Agent Types Link Info</code>:</p> <ul> <li>Allows you to configure <code>NavMeshLink</code> generation settings on a per-agent-type basis (Agent Types are defined in Unity's Navigation settings). Add entries to this list to customize link generation.</li> <li><code>Agent Type</code>: The specific agent type this link configuration applies to.</li> <li><code>Area</code>: The NavMesh Area type assigned to the generated link (e.g., \"Walkable\", \"Jump\"). This allows different agents to treat traversals differently.</li> <li>Only relevant if <code>Link Rooms</code> is checked.</li> </ul> </li> <li> <p><code>Disable When Door is Closed</code>:</p> <ul> <li>Functionality: If checked, the generated <code>NavMeshLink</code>'s enabled state will be controlled by the <code>IsOpen</code> property of the Door Component found on any door prefab placed in the doorway.</li> <li>Requires: Your door prefabs must have a script that correctly updates the <code>Door</code> component's <code>IsOpen</code> status when the door opens or closes.</li> <li>Purpose: Allows doors to dynamically block or allow pathfinding routes. Only relevant if <code>Link Rooms</code> is checked.</li> </ul> </li> <li> <p><code>Auto-Generate Surfaces</code>:</p> <ul> <li>Visible Only: This setting only appears when <code>Runtime Bake Mode</code> is set to <code>Full Dungeon Bake</code>.</li> <li>Functionality:<ul> <li>If checked, the adapter automatically creates a default <code>NavMeshSurface</code> configuration for each Agent Type defined in your project settings during the full dungeon bake.</li> <li>If unchecked, you must manually provide a list of pre-configured <code>NavMeshSurface</code> components (e.g., on the same GameObject as the adapter) that will be used for the full dungeon bake. This gives you more control over the baking settings (voxel size, agent radius, etc.).</li> </ul> </li> </ul> </li> </ul>"},{"location":"pathfinding/unity-navmesh/#handling-doors","title":"Handling Doors","text":"<p>As mentioned in the settings:</p> <ol> <li>Ensure <code>Link Rooms</code> is checked (unless using <code>Full Dungeon Bake</code>).</li> <li>Ensure <code>Disable When Door is Clos</code> is checked.</li> <li>Your door prefabs (used as Connectors/Blockers or via Lock &amp; Key) must have a script attached that includes a <code>Door</code> component and correctly sets its <code>IsOpen</code> property to <code>true</code> when the door is open and <code>false</code> when it's closed.</li> </ol> <p>DunGen will then automatically toggle the associated <code>NavMeshLink</code> component based on the door's state.</p>"},{"location":"pathfinding/unity-navmesh/#2d-navmesh-integration","title":"2D NavMesh Integration","text":"<p>DunGen also provides limited support for 2D NavMesh generation using Unity's NavMesh Components.</p> <p>Use the Correct Adapter</p> <p>For 2D projects, you must use the <code>Unity NavMesh Adapter (2D)</code> component instead of the standard <code>Unity Nav Mesh Adapter</code>.</p> <p>The 2D adapter works similarly but specifically looks for the following components within your Tile prefabs to generate the NavMesh shape:</p> <ul> <li><code>SpriteRenderer</code>: Considers the sprite's mesh data. Uses the layers defined in the adapter's \"Included Layers\" setting to determine walkability (sprites on other layers are considered non-walkable).</li> <li><code>Tilemap</code>: Considers tiles based on their <code>Collider Type</code>:<ul> <li><code>None</code>: Considered walkable.</li> <li><code>Sprite</code> or <code>Grid</code>: Considered non-walkable obstacles.</li> <li>The shape is derived from the tile's mesh, not its collider shape.</li> </ul> </li> </ul> <p>Other settings on the 2D adapter generally mirror the standard adapter where applicable.</p> <p>By using the appropriate Unity NavMesh Adapter, you can seamlessly integrate robust pathfinding into your DunGen-generated levels. Choose the <code>Runtime Bake Mode</code> and configure linking options carefully based on your project's needs and performance targets.</p>"},{"location":"reference/cookbook/","title":"DunGen Cookbook: Practical Recipes","text":"<p>Welcome to the DunGen Cookbook! This section provides a collection of practical examples, code snippets, and solutions for common tasks and customizations you might want to implement when working with DunGen.</p> <p>Think of these entries as focused \"recipes\" designed to help you quickly achieve a specific goal without necessarily diving deep into the underlying theory (though links to relevant documentation sections may be provided).</p> <p>Prerequisites</p> <p>These recipes generally assume you have a basic understanding of DunGen's core concepts, such as Tiles, Doorways, Dungeon Flow, and the Runtime Dungeon component, as covered in the Getting Started and Core Concepts sections.</p>"},{"location":"reference/cookbook/#how-to-use-this-section","title":"How to Use This Section","text":"<p>Browse the list of recipes below. Each link will take you to a dedicated page containing the specific example, code snippets, and explanations needed to implement that particular feature.</p> <p>Adaptation May Be Required</p> <p>The code provided in these recipes is intended as a starting point and example. You may need to adapt it to fit the specific needs and architecture of your own project.</p>"},{"location":"reference/cookbook/#recipe-index","title":"Recipe Index","text":"<p>Here are the currently available recipes:</p> <ul> <li>Spawning the Player at Spawn Points</li> <li>Main Path Connection Rule</li> <li>Line Segment Injection</li> <li>Programmatically Modifying DunGen Assets</li> </ul>"},{"location":"reference/faq/","title":"Frequently Asked Questions","text":""},{"location":"reference/faq/#can-dungen-be-used-for-2d-games","title":"Can DunGen be used for 2D games?","text":"<p>Yes. DunGen works just as well with 2D games as it does with 3D. There's even a (very) simple 2D demo scene included.</p>"},{"location":"reference/faq/#does-dungen-support-loops","title":"Does DunGen support loops?","text":"<p>Loops (paths that connect back up to the rest of the dungeon) are not supported. You can achieve incidental loops by using the <code>Doorway Connection Chance</code> feature in the DungeonFlow. This will try to connect any Doorways that coincidentally overlap, but were otherwise not connected.</p>"},{"location":"reference/faq/#can-i-generate-dungeons-in-the-editor-or-does-dungen-only-support-runtime-dungeons","title":"Can I generate dungeons in the editor, or does DunGen only support runtime dungeons?","text":"<p>DunGen can generate dungeon layouts entirely in the editor if you'd like. Just use the window located on the main menu under <code>Window &gt; DunGen &gt; Generate Dungeon</code>.</p>"},{"location":"reference/faq/#can-you-save-a-dungeon-layout-and-come-back-to-it-later","title":"Can you save a dungeon layout and come back to it later?","text":"<p>The random number generator used by DunGen is seeded. If you need your players to be able to revisit a previous floor, for example, you would store the seed used to generate that floor. DunGen could then take that seed and generate an identical layout (including props). Of course, you'd need to also save any changes that were made to the dungeon (such as chests being opened) and re-apply them once DunGen has finished generating the layout.</p>"},{"location":"reference/faq/#does-dungen-work-with-outdoor-dungeons-as-well","title":"Does DunGen work with outdoor dungeons as well?","text":"<p>While DunGen wasn't made with outdoor scenes in mind, it doesn't care what is contained within a tile. These are a few things you'll have to consider when using DunGen in an outdoor setting:</p> <ul> <li>DunGen was made for interior scenes, so in order to avoid your scene looking like a corridor, each Tile will need to be fairly large.</li> <li>You'll need a way to cover any Tile edges that aren't connected. The best way to do this is to have a cliff mesh (or some other large, natural structure) that blocks the edge of the tile. You'd then use a Doorways Blocker list to make this mesh only appear when the Tile is not connected to anything along that edge. See the Doorways section for more information.</li> <li>Standard portal culling won't provide much benefit (if any) when your doorways stretch the length of your tile. You'll need to make use of some other culling solution.</li> </ul>"},{"location":"reference/faq/#will-dungen-work-with-this-art-pack","title":"Will DunGen work with this art pack?","text":"<p>There are no strict requirements when it comes to the assets you use with DunGen. Any modular art pack should work without issue (although if you're mixing packs, it's best if all of the art uses the same grid size).</p>"},{"location":"reference/cookbook/line-segment-injection/","title":"Line Segment Injection","text":"<p>The following example script demonstrates how to procedurally add tile injection rules, allowing us to inject tiles onto specific line segments in the dungeon flow.</p> <pre><code>using DunGen;\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n/// &lt;summary&gt;\n/// Injects tiles into the dungeon based on the line segment inside the dungeon flow. 0 is the first line segment in the dungeon flow\n/// &lt;/summary&gt;\npublic class TileSegmentInjector : MonoBehaviour\n{\n    [Serializable]\n    public class LineSegmentInjectedTileSet\n    {\n        /// &lt;summary&gt;\n        /// Which line segment does this rule apply to? 0 is the first line segment in the dungeon flow\n        /// &lt;/summary&gt;\n        public int LineSegmentIndex = 0;\n        /// &lt;summary&gt;\n        /// The tile set to inject\n        /// &lt;/summary&gt;\n        public TileSet TileSet = null;\n        /// &lt;summary&gt;\n        /// If required, DunGen will retry generating the dungeon until this tile is successfully injected\n        /// &lt;/summary&gt;\n        public bool Required = true;\n    }\n\n    /// &lt;summary&gt;\n    /// The runtime dungeon to inject tiles into\n    /// &lt;/summary&gt;\n    public RuntimeDungeon RuntimeDungeon = null;\n    /// &lt;summary&gt;\n    /// Padding as a percentage of the line segment, to prevent injected tiles from appearing too close to the start or end of the segment\n    /// &lt;/summary&gt;\n    [Range(0f, 25f)]\n    public float PaddingPercentage = 0.0f;\n    /// &lt;summary&gt;\n    /// A list of injection rules\n    /// &lt;/summary&gt;\n    public List&lt;LineSegmentInjectedTileSet&gt; InjectionRules = new List&lt;LineSegmentInjectedTileSet&gt;();\n\n\n    private void OnEnable()\n    {\n        if(RuntimeDungeon == null)\n            RuntimeDungeon = FindObjectOfType&lt;RuntimeDungeon&gt;();\n\n        if(RuntimeDungeon != null)\n            RuntimeDungeon.Generator.TileInjectionMethods += InjectTiles;\n    }\n\n    private void OnDisable()\n    {\n        if (RuntimeDungeon != null)\n            RuntimeDungeon.Generator.TileInjectionMethods -= InjectTiles;\n    }\n\n    private void InjectTiles(RandomStream randomStream, ref List&lt;InjectedTile&gt; tilesToInject)\n    {\n        var generator = RuntimeDungeon.Generator;\n        var dungeonFlow = generator.DungeonFlow;\n\n        float normalizedPaddingPercentage = PaddingPercentage / 100.0f;\n        float normalizedLengthSoFar = 0.0f;\n\n        for (int i = 0; i &lt; dungeonFlow.Lines.Count; i++)\n        {\n            float min = normalizedLengthSoFar;\n            float max = normalizedLengthSoFar + dungeonFlow.Lines[i].Length;\n            float length = max - min;\n\n            var rule = InjectionRules.Find(x =&gt; x.LineSegmentIndex == i);\n\n            if(rule != null)\n            {\n                float normalizedPathDepth = Mathf.Lerp(min + normalizedPaddingPercentage, max - normalizedPaddingPercentage, (float)randomStream.NextDouble());\n                tilesToInject.Add(new InjectedTile(rule.TileSet, true, normalizedPathDepth, 0.0f, rule.Required));\n            }\n\n            normalizedLengthSoFar = max;\n        }\n    }\n}\n</code></pre>"},{"location":"reference/cookbook/main-path-connections/","title":"Use a Specific Socket for the Main Path","text":"<ul> <li>Goal: We want to force all main path connections to use a specific doorway socket. All Tiles along the main path will have to connect to one-another (and to branch Tiles that start from them), using a <code>DoorwaySocket</code> that we specify.</li> <li>Usage: Attach the script to any GameObject in the scene and assign an appropriate socket to the MainPathSocket field in the inspector.</li> </ul> MainPathConnectionRule.cs<pre><code>using DunGen;\nusing UnityEngine;\n\npublic class MainPathConnectionRule : MonoBehaviour\n{\n    public DoorwaySocket MainPathSocket = null;\n\n    private TileConnectionRule rule;\n\n\n    private void OnEnable()\n    {\n        rule = new TileConnectionRule(CanTilesConnect);\n        DoorwayPairFinder.CustomConnectionRules.Add(rule);\n    }\n\n    private void OnDisable()\n    {\n        DoorwayPairFinder.CustomConnectionRules.Remove(rule);\n        rule = null;\n    }\n\n    private TileConnectionRule.ConnectionResult CanTilesConnect(ProposedConnection connection)\n    {\n        bool isOnMainPath = connection.PreviousTile.Placement.IsOnMainPath;\n\n        // We're only interested in main path connections\n        if (isOnMainPath)\n        {\n            // Only allow main path connections if they use the correct socket on both doorways\n            bool allowConnection =  connection.PreviousDoorway.Socket == MainPathSocket &amp;&amp;\n                                    connection.NextDoorway.Socket == MainPathSocket;\n\n            if (allowConnection)\n                return TileConnectionRule.ConnectionResult.Allow;\n            else\n                return TileConnectionRule.ConnectionResult.Deny;\n        }\n        // If we're not on the main path, just ignore it\n        else\n            return TileConnectionRule.ConnectionResult.Passthrough;\n    }\n}\n</code></pre>"},{"location":"reference/cookbook/modify-dungeon-flow/","title":"Programmatically Modify the DungeonFlow","text":"<p>It's possible to modify the DungeonFlow or any other DunGen asset at runtime to manipulate how the dungeon is generated.</p> <p>Permanent Changes</p> <p>Care must be taken when modifying any DunGen asset that derives from <code>ScriptableObject</code> (e.g., TileSet, Archetype, DungeonFlow, etc). Modifying these assets will make permanent changes to your project. You will need to copy the asset first (using <code>Instantiate(originalAsset)</code>) and work only on the duplicate asset to avoid permanent change to your project. You'll also need to consider deep copies if, for example, you'd like to change one of the Tiles inside a <code>TileSet</code> that belongs to your <code>DungeonFlow</code>.</p> <p>Here's an example of how you could duplicate a <code>DungeonFlow</code> and swap the Tiles that appear on the Goal node with one or more boss Tiles. Useful for if you'd like a boss to appear only on certain floors, but otherwise want the DungeonFlow to be identical to your regular floors, and don't want to have to maintain multiple near-identical Dungeon Flows.</p> SwapGoalNode.cs<pre><code>using DunGen;\nusing DunGen.Graph;\nusing System.Linq;\nusing UnityEngine;\n\npublic class SwapGoalNode : MonoBehaviour\n{\n    /// &lt;summary&gt;\n    /// The original dungeon flow asset we want to swap the goal of\n    /// &lt;/summary&gt;\n    public DungeonFlow OriginalFlow;\n    /// &lt;summary&gt;\n    /// The replacement boss room tiles to use as the goal\n    /// &lt;/summary&gt;\n    public TileSet BossRoomTileSet;\n\n    /// &lt;summary&gt;\n    /// The duplicated dungeon flow with its goal overridden. We can pass this\n    /// to the dungeon generator to generate a copy of our dungeon with the swapped goal node\n    /// &lt;/summary&gt;\n    public DungeonFlow BossRoomFlow { get; private set; }\n\n\n    private void Start()\n    {\n        if (OriginalFlow == null)\n            return;\n\n        // Make a copy of the original flow\n        // IMPORTANT: Be very careful modifying the dungeon flow asset at runtime. Since it's a \n        // ScriptableObject, any changes to the original will affect the settings inside your actual project.\n        // This also goes for sub-objects inside the dungeon flow (such as TileSets). Anything derived from a\n        // ScriptableObject should be duplicated first before any modifications are applied to avoid making\n        // permanent changes to your project\n        BossRoomFlow = Instantiate(OriginalFlow);\n\n        // Find the goal node\n        var goalNode = BossRoomFlow.Nodes.First(x =&gt; x.NodeType == NodeType.Goal);\n\n        // Set the boss room TileSet as the only goal node\n        goalNode.TileSets.Clear();\n        goalNode.TileSets.Add(BossRoomTileSet);\n\n        // Now we can pass our new BossRoomFlow into the Generator of our RuntimeDungeon component and call Generate()\n    }\n}\n</code></pre>"},{"location":"reference/cookbook/spawn-player/","title":"Spawning the Player","text":"<ul> <li>Goal: We want to spawn our player prefab at a random spawn point, designated by a Unity tag,</li> <li>Usage:<ol> <li>Create a Unity tag that will be used to identify your potential spawn points.</li> <li>Attach the script to any GameObject outside of the dungeon hierarchy.</li> <li>In the inspector, set the <code>RuntimeDungeon</code> to the dungeon generator you want to use and set <code>PlayerPrefab</code> to the player prefab you want to spawn. Set the <code>SpawnPointTag</code> to the tag created earlier.</li> <li>Apply the tag to empty objects placed inside your Tiles. These are the places where the player can spawn.</li> </ol> </li> </ul> SimplePlayerSpawner.cs<pre><code>using DunGen;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\n\npublic class SimplePlayerSpawner : MonoBehaviour\n{\n    // The dungeon generator we are using\n    public RuntimeDungeon RuntimeDungeon;\n    // The prefab we want to spawn to represent the player\n    public GameObject PlayerPrefab;\n    // The tag we are using to identify spawn points\n    public string SpawnPointTag = \"PlayerSpawn\";\n    // Whether we should only spawn on the start tile\n    public bool StartTileOnly = true;\n\n    private GameObject player;\n\n\n    private void OnEnable()\n    {\n        RuntimeDungeon.Generator.OnGenerationStatusChanged += OnDungeonGenerationStatusChanged;\n    }\n\n    private void OnDisable()\n    {\n        RuntimeDungeon.Generator.OnGenerationStatusChanged -= OnDungeonGenerationStatusChanged;\n    }\n\n    private void OnDungeonGenerationStatusChanged(DungeonGenerator generator, GenerationStatus status)\n    {\n        if (status == GenerationStatus.Complete)\n            SpawnPlayer(generator.CurrentDungeon);\n        else\n        {\n            // Destroy any existing player\n            if (player != null)\n                Destroy(player);\n        }\n    }\n\n    private void SpawnPlayer(Dungeon dungeon)\n    {\n        // Determine where the player can spawn\n        var hierarchyToSearch = (StartTileOnly) ? dungeon.MainPathTiles[0].transform : dungeon.transform;\n\n        // Find all valid spawn points (all GameObjects with the appropriate tag) within out chosen search hierarchy\n        var spawnPoints = FindSpawnPointsInHierarchy(hierarchyToSearch);\n\n        // Select one of the spawn points at random\n        int spawnPointIndex = UnityEngine.Random.Range(0, spawnPoints.Count());\n        var selectedSpawnPoint = spawnPoints.ElementAt(spawnPointIndex);\n\n        // Spawn the player prefab at the target\n        player = Instantiate(PlayerPrefab, selectedSpawnPoint.position, selectedSpawnPoint.rotation);\n    }\n\n    /// &lt;summary&gt;\n    /// Search through a transform hierarchy to find any objects with the appropriate tag\n    /// &lt;/summary&gt;\n    private IEnumerable&lt;Transform&gt; FindSpawnPointsInHierarchy(Transform currentTransform)\n    {\n        if (currentTransform.gameObject.CompareTag(SpawnPointTag))\n            yield return currentTransform;\n\n        for (int i = 0; i &lt; currentTransform.childCount; i++)\n        {\n            var childTransform = currentTransform.GetChild(i);\n\n            foreach (var spawnPoint in FindSpawnPointsInHierarchy(childTransform))\n                yield return spawnPoint;\n        }\n    }\n}\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting: Overview","text":"<p>While DunGen aims to be robust and easy to use, you might occasionally encounter unexpected behaviour, performance issues, or situations where the generated dungeon doesn't quite meet your expectations. This section provides guidance on identifying and resolving common problems, understanding DunGen's limitations, and analysing the generation process.</p>"},{"location":"troubleshooting/#topics-covered","title":"Topics Covered:","text":"<ul> <li> <p>Limitations &amp; Considerations:     Before diving into complex debugging, understand the inherent design constraints of DunGen. This page covers crucial aspects like the requirements for Doorway Placement relative to a Tile's bounding box (AABB) and how the collision system works. Understanding these limitations can often explain why certain layouts might fail or why specific Tile shapes are problematic.</p> </li> <li> <p>Analysing Generation Performance:     Performance analysis is crucial for optimizing your dungeon generation, especially for complex layouts or lower-spec target platforms. This page introduces tools like the <code>Runtime Analyzer</code> component for gathering statistics on generation time and failure rates, and how to use asynchronous generation with pauses for visual debugging of the step-by-step layout process. Understanding where time is spent or why generation might fail is the first step to fixing it.</p> </li> </ul>"},{"location":"troubleshooting/#common-issues-general-guidance","title":"Common Issues (General Guidance)","text":"<p>While specific issues often relate to the topics above, here are some general areas to investigate when troubleshooting:</p> <ul> <li>Generation Failures: If DunGen frequently fails to generate a dungeon (especially noticeable in the Editor where it has a retry limit), check:<ul> <li>Insufficient Tile Variety: Do you have enough unique Tile prefabs, especially if using <code>Disallow</code> repeat modes?</li> <li>Overly Restrictive Rules: Are your Tile Connection Rules too strict? Are your Tile Injection rules impossible to satisfy?</li> <li>Tight Constraints: Is the dungeon length too long for the available space, or are the branch constraints too demanding?</li> <li>Incorrect Doorway Placement: Are doorways placed correctly on the Tile bounds as described in Limitations?</li> <li>Scene Collisions: Is DunGen colliding with hidden or unexpected objects in the scene?</li> </ul> </li> <li>Performance Problems: If generation is slow or causes hitches:<ul> <li>Complex Tiles: Are your Tile prefabs overly detailed or have too many components?</li> <li>Instantiation Cost: Consider enabling Tile Pooling.</li> <li>Runtime Baking: Is runtime pathfinding baking (Unity NavMesh, A* Pathfinding) taking too long? Consider pre-baking or optimizing bake settings.</li> <li>Use the tools described in Analyzing Performance to pinpoint bottlenecks.</li> </ul> </li> <li>Visual Glitches: Check Tile prefab alignment, Doorway component orientation, and ensure materials/shaders are compatible with runtime instantiation if issues arise.</li> </ul> <p>Refer to the specific pages in this section for more detailed solutions and techniques related to these common troubleshooting areas.</p>"},{"location":"troubleshooting/analysis/","title":"Troubleshooting: Analysing Generation Performance &amp; Process","text":"<p>When your dungeon generation isn't working as expected, whether it's failing frequently, taking too long, or producing undesirable layouts, you need ways to diagnose the problem. DunGen provides tools and features to help you analyse the performance and visualize the step-by-step process of dungeon creation.</p>"},{"location":"troubleshooting/analysis/#generation-statistics","title":"Generation Statistics","text":"<p>The generation statistics window provides some simple information about your successful dungeon generation.</p> <ul> <li>What it Does: Provides a list of basic statistics including total generation time, the number of rooms of each type that were spawned, total retry count, and how long each step in the generation process took.</li> <li>How to Use:<ol> <li>Open the generation statistics window (<code>Window &gt; DunGen &gt; Generation Stats</code>).</li> <li>Generate a dungeon. This can be done at runtime using the <code>Runtime Dungeon</code> component or in the editor (<code>Window &gt; DunGen &gt; Generate Dungeon</code>).</li> <li>The window will update to show that stats of the last generated dungeon. Generating another dungeon will update the stats for the new dungeon generation.</li> </ol> </li> </ul>"},{"location":"troubleshooting/analysis/#runtime-analyzer-component","title":"Runtime Analyzer Component","text":"<p>For quantitative analysis, especially regarding performance and success rates over multiple runs, DunGen provides the <code>Runtime Analyzer</code> component.</p> <ul> <li>What it Does: This component repeatedly generates dungeons using specified settings and gathers statistics about the process, such as average generation time, failure rates, and time spent on different generation steps.</li> <li>How to Use (Easiest Way):<ol> <li>Locate the demo scene provided with DunGen: <code>Assets/DunGen/Demo/Analysis Scene</code>.</li> <li>Open this scene.</li> <li>Find the <code>Analyzer</code> GameObject in the hierarchy.</li> <li>In the Inspector, find the <code>Runtime Dungeon (Script)</code> component attached to the <code>Analyzer</code> GameObject.</li> <li>Replace the default <code>Dungeon Flow</code> asset in its slot with your own <code>Dungeon Flow</code> asset that you want to test.</li> <li>Enter Play mode. The analyser will run multiple generation cycles (configurable on the <code>Runtime Analyzer</code> component) and print the statistics to the Console once finished.</li> </ol> </li> <li>How to Use (Manual Setup):<ol> <li>Add the <code>Runtime Analyzer</code> component to a GameObject in your scene (<code>Add Component &gt; DunGen &gt; Analysis &gt; Runtime Analyzer</code>).</li> <li>Ensure this GameObject also has a <code>Runtime Dungeon</code> component configured with your desired settings.</li> <li>Configure the <code>Runtime Analyzer</code> settings (number of iterations, etc.).</li> <li>Enter Play mode.</li> </ol> </li> <li>What Information it Provides:<ul> <li>Total number of successful generations vs. attempts.</li> <li>Average time taken per successful generation.</li> <li>Average time spent on specific phases (e.g., Main Path Generation, Branch Path Generation, Post-Processing).</li> <li>Average number of rooms in total, as well as individually on the Main Path and Branch Paths.</li> </ul> </li> <li>Why it's Useful:<ul> <li>Identifies performance bottlenecks (which step takes the longest?).</li> <li>Quantifies the impact of changes (e.g., did adding more complex tiles significantly increase generation time?).</li> <li>Helps determine if generation failures are frequent or rare under specific rule sets.</li> </ul> </li> </ul>"},{"location":"troubleshooting/analysis/#asynchronous-generation-visualization","title":"Asynchronous Generation Visualization","text":"<p>Sometimes, seeing how the dungeon is built step-by-step is more revealing than statistics, especially when debugging layout failures or unexpected tile placements. You can achieve this using DunGen's asynchronous generation mode with pauses.</p> <ul> <li>What it Does: Allows DunGen to generate the dungeon over multiple frames and optionally pause after placing each Tile, letting you watch the process unfold in the Scene view.</li> <li>How to Enable:<ol> <li>Select the GameObject containing your <code>Runtime Dungeon</code> component.</li> <li>In the Inspector, find these settings:<ul> <li><code>Generate Asynchronously</code>: Check this box. This tells DunGen not to block the main thread during generation, enabling pauses.</li> <li><code>Pause Between Rooms</code>: Set this to a small positive value (e.g., <code>0.5</code> or <code>1.0</code>). This is the duration (in seconds) DunGen will pause after placing each room/tile. A value of <code>0</code> means no pause.</li> </ul> </li> <li>Enter Play mode. Observe the Scene view as the dungeon constructs itself incrementally.</li> </ol> </li> <li>Why it's Useful:<ul> <li>Visual Debugging: See the exact order tiles are placed and connected.</li> <li>Failure Point Identification: If generation fails, you can often see exactly which tile placement failed or where the process got stuck.</li> <li>Understanding Logic: Visually grasp how main path vs. branch path generation proceeds, how connection rules are applied, or why certain areas might be unreachable.</li> <li>Collision Issues: Helps spot if tiles are colliding unexpectedly with each other or scene objects during placement.</li> </ul> </li> </ul> <p>By utilizing the <code>Runtime Analyzer</code> for performance metrics and asynchronous visualization for process debugging, you gain valuable insights into how DunGen is operating, making it much easier to troubleshoot issues and optimize your procedural dungeon generation setup.</p>"},{"location":"troubleshooting/limitations/","title":"Troubleshooting: Limitations &amp; Considerations","text":"<p>DunGen is a powerful tool, but like any system, it operates based on certain internal logic and assumptions. Understanding these limitations is crucial for designing compatible content and troubleshooting potential generation failures. Being aware of these constraints upfront can save significant debugging time.</p> <p>The most critical limitation relates to how DunGen performs collision checks between Tiles.</p>"},{"location":"troubleshooting/limitations/#doorway-placement","title":"Doorway Placement","text":"<ul> <li> <p>The Core Mechanism: DunGen determines if Tiles overlap by checking their Axis-Aligned Bounding Boxes (AABB). This is a fast and efficient method suitable for runtime generation, but it's less precise than mesh-based collision.</p> </li> <li> <p>The Critical Rule: Because collision is based on the AABB, Doorway components MUST be placed on the outer edge of their Tile's calculated AABB.</p> </li> <li> <p>What This Means:</p> <ul> <li>The Doorway component's position must lie on one of the six faces of the invisible rectangular box that encompasses all renderers and colliders within the Tile prefab.</li> <li>DunGen can handle doorways that are slightly offset from the absolute edge, but they must fundamentally reside on the boundary plane of the AABB.</li> </ul> </li> <li> <p>The Problem - Concave Shapes: Doorways placed on concave portions of a Tile (parts that indent inwards relative to the overall bounding box) will NOT work. DunGen's connection logic relies on finding doorways on the AABB edge where two tiles meet. If a doorway is inside this edge, it won't be detected correctly for connections.</p> </li> <li> <p>Visual Example:     The image below illustrates this. The <code>orange box</code> represents the Tile's AABB, and the <code>blue line</code> represents the Doorway's position.</p> <ul> <li>(\u2713 Correct): Doorways are placed on the flat, outer edges of the AABB. Even if the visible mesh curves slightly inside the AABB near the doorway, the Doorway component itself is positioned on the AABB boundary.</li> <li>(X Incorrect): Doorways are placed on indented parts of the Tile geometry. These positions are inside the AABB's boundary, not on its edge. DunGen cannot connect these doorways.</li> </ul> <p></p> </li> <li> <p>When Does This Matter Most?</p> <ul> <li>Simple Rectangular Tiles: If your tiles are basically rectangular prisms, this is usually not a concern, as all walls naturally align with the AABB edges.</li> <li>Complex Shapes (L-shapes, T-shapes, Alcoves, etc.): This restriction becomes extremely important when designing Tiles with non-rectangular footprints. You must ensure doorways are only placed on segments of the Tile that correspond to the outer faces of its overall bounding box. Visualize the AABB around your complex tile and place doorways accordingly.</li> </ul> </li> </ul> <p>Consequences of Incorrect Placement</p> <p>Failing to adhere to the AABB edge placement rule for Doorways is a common cause of dungeon generation failures or unexpected connectivity issues. If DunGen seems unable to connect certain tiles, verify the Doorway placement relative to the Tile's AABB.</p>"},{"location":"troubleshooting/limitations/#other-considerations","title":"Other Considerations","text":"<ul> <li>Performance: While not a hard limitation on what can be generated, extremely complex Tile prefabs (high polygon counts, numerous components, complex scripts) can increase instantiation time and potentially impact runtime generation performance. Consider optimization or using features like Tile Pooling.</li> </ul> <p>Understanding the AABB collision system and its implication for doorway placement is the most important technical limitation to grasp when designing content for DunGen, especially when moving beyond simple rectangular rooms.</p>"}]}